<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>WSL on Christian Amado's Blog</title><link>https://cmas.dev/tags/wsl/</link><description>Recent content in WSL on Christian Amado's Blog</description><generator>Hugo -- gohugo.io</generator><language>es</language><lastBuildDate>Thu, 09 Jan 2025 00:00:00 -0400</lastBuildDate><atom:link href="https://cmas.dev/tags/wsl/index.xml" rel="self" type="application/rss+xml"/><item><title>Optimización avanzada de rendimiento en WSL para desarrollo intensivo</title><link>https://cmas.dev/posts/2025-01-09-optimization-wsl-2/</link><pubDate>Thu, 09 Jan 2025 00:00:00 -0400</pubDate><guid>https://cmas.dev/posts/2025-01-09-optimization-wsl-2/</guid><description>&lt;p>El Subsistema de Windows para Linux (WSL) ha demostrado ser una herramienta esencial para desarrolladores que buscan integrar Linux en su flujo de trabajo en Windows. Sin embargo, para obtener el mejor rendimiento en escenarios de desarrollo intensivo, es importante realizar ajustes y configuraciones avanzadas. En este artículo, aprenderás cómo optimizar &lt;strong>WSL&lt;/strong> con ejemplos prácticos y código, además de visualizar los resultados con capturas de pantalla y diagramas.&lt;/p>
&lt;h2 id="1-configuración-de-recursos-asignados">1. Configuración de recursos asignados&lt;/h2>
&lt;p>WSL 2 utiliza una máquina virtual ligera para ejecutar el kernel de Linux. De forma predeterminada, WSL asigna recursos de manera dinámica, pero puedes ajustar manualmente la cantidad de CPU y memoria disponibles para mejorar el rendimiento.&lt;/p>
&lt;h3 id="paso-1-crear-o-editar-el-archivo-wslconfig">Paso 1: Crear o editar el archivo &lt;code>.wslconfig&lt;/code>&lt;/h3>
&lt;ol>
&lt;li>Abre el archivo &lt;code>.wslconfig&lt;/code> en el directorio de tu usuario:
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">notepad %USERPROFILE%\.wslconfig
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>Configura los parámetros según tus necesidades:
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">[wsl2]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">memory=4GB # Límite de memoria RAM
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">processors=2 # Número de CPUs asignadas
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>Reinicia WSL para aplicar los cambios:
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">wsl --shutdown
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">wsl
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;h2 id="2-mejorar-el-rendimiento-del-sistema-de-archivos">2. Mejorar el rendimiento del sistema de archivos&lt;/h2>
&lt;p>Las operaciones de E/S son un área donde el rendimiento puede degradarse, especialmente al trabajar con archivos en el sistema de Windows desde Linux. Para mejorar esto:&lt;/p>
&lt;h3 id="paso-1-usa-el-sistema-de-archivos-de-linux-para-proyectos-intensivos">Paso 1: Usa el sistema de archivos de Linux para proyectos intensivos&lt;/h3>
&lt;p>Guarda tu código y datos en el sistema de archivos nativo de Linux (&lt;code>/home/&amp;lt;usuario&amp;gt;&lt;/code> en lugar de &lt;code>/mnt/c&lt;/code>) para minimizar la latencia.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl"># Crear un directorio en el sistema de archivos de Linux
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mkdir -p ~/projects/my-intensive-app
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># Clonar un repositorio
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cd ~/projects/my-intensive-app
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git clone https://github.com/example/project.git
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="paso-2-deshabilitar-el-acceso-automático-a-carpetas-de-windows">Paso 2: Deshabilitar el acceso automático a carpetas de Windows&lt;/h3>
&lt;p>Evita que WSL indexe innecesariamente carpetas de Windows configurando los métodos de montaje:&lt;/p>
&lt;ol>
&lt;li>Agrega esta configuración a &lt;code>.wslconfig&lt;/code>:
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">[automount]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">enabled=false
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>Reinicia WSL.&lt;/li>
&lt;/ol>
&lt;h3 id="visualización">Visualización&lt;/h3>
&lt;p>&lt;img src="https://i.ibb.co/NNF0gF4/lectura-vs-escritura-wsl.png" alt="">&lt;/p>
&lt;h2 id="3-configurar-un-servidor-dns-personalizado">3. Configurar un servidor DNS personalizado&lt;/h2>
&lt;p>Por defecto, WSL utiliza el servidor DNS de Windows. Sin embargo, puedes mejorar el rendimiento de las solicitudes de red configurando un servidor DNS optimizado.&lt;/p>
&lt;h3 id="paso-1-modificar-el-archivo-de-resolución-de-dns">Paso 1: Modificar el archivo de resolución de DNS&lt;/h3>
&lt;ol>
&lt;li>Crea o edita &lt;code>/etc/wsl.conf&lt;/code> en tu distribución:
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">sudo nano /etc/wsl.conf
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>Agrega las siguientes líneas:
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">[network]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">generateResolvConf = false
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>Configura manualmente el servidor DNS:
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">sudo rm /etc/resolv.conf
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">echo &amp;#34;nameserver 8.8.8.8&amp;#34; | sudo tee /etc/resolv.conf
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>Reinicia WSL:
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">wsl --shutdown
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">wsl
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">## 4. Habilitar aceleración de hardware para Docker&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Si&lt;/span> &lt;span class="n">utilizas&lt;/span> &lt;span class="n">Docker&lt;/span> &lt;span class="n">en&lt;/span> &lt;span class="n">WSL&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">habilitar&lt;/span> &lt;span class="n">la&lt;/span> &lt;span class="n">aceleración&lt;/span> &lt;span class="n">de&lt;/span> &lt;span class="n">hardware&lt;/span> &lt;span class="n">puede&lt;/span> &lt;span class="n">reducir&lt;/span> &lt;span class="n">los&lt;/span> &lt;span class="n">tiempos&lt;/span> &lt;span class="n">de&lt;/span> &lt;span class="n">construcción&lt;/span> &lt;span class="n">y&lt;/span> &lt;span class="n">mejorar&lt;/span> &lt;span class="n">la&lt;/span> &lt;span class="n">eficiencia&lt;/span> &lt;span class="n">general&lt;/span>&lt;span class="o">.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">### Paso 1: Instalar los controladores de GPU&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mf">1.&lt;/span> &lt;span class="n">Asegúrate&lt;/span> &lt;span class="n">de&lt;/span> &lt;span class="n">tener&lt;/span> &lt;span class="n">los&lt;/span> &lt;span class="n">controladores&lt;/span> &lt;span class="n">de&lt;/span> &lt;span class="n">GPU&lt;/span> &lt;span class="n">compatibles&lt;/span> &lt;span class="n">con&lt;/span> &lt;span class="n">WSL&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="n">instalados&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">-&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">Controladores&lt;/span> &lt;span class="n">NVIDIA&lt;/span> &lt;span class="n">para&lt;/span> &lt;span class="n">CUDA&lt;/span> &lt;span class="n">en&lt;/span> &lt;span class="n">WSL&lt;/span>&lt;span class="p">](&lt;/span>&lt;span class="n">https&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="n">developer&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">nvidia&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">com&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">cuda&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">wsl&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">### Paso 2: Configurar Docker para usar GPU&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mf">1.&lt;/span> &lt;span class="n">Instala&lt;/span> &lt;span class="n">el&lt;/span> &lt;span class="n">paquete&lt;/span> &lt;span class="err">`&lt;/span>&lt;span class="n">nvidia&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">container&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">toolkit&lt;/span>&lt;span class="err">`&lt;/span> &lt;span class="n">dentro&lt;/span> &lt;span class="n">de&lt;/span> &lt;span class="n">tu&lt;/span> &lt;span class="n">distribución&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>sudo apt update
sudo apt install -y nvidia-container-toolkit&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">2. Verifica que la GPU esté disponible:
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>docker run &amp;ndash;rm &amp;ndash;gpus all nvidia/cuda:11.0-base nvidia-smi&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">## 5. Ajustar la configuración del kernel Linux
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">WSL 2 utiliza un kernel Linux real que puede ajustarse para optimizar su rendimiento. Esto se logra a través del archivo `/etc/sysctl.conf`.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">### Paso 1: Optimizar parámetros de red
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1. Edita `/etc/sysctl.conf`:
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>sudo nano /etc/sysctl.conf&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">2. Agrega los siguientes ajustes:
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>net.core.default_qdisc=fq
net.ipv4.tcp_congestion_control=bbr&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">3. Aplica los cambios:
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>sudo sysctl -p&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">## Conclusión
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Con estos ajustes, puedes optimizar **WSL** para maximizar su rendimiento en proyectos de desarrollo intensivo. Desde la asignación eficiente de recursos hasta la configuración de red y almacenamiento, estos pasos te ayudarán a aprovechar al máximo esta poderosa herramienta.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Internals de WSL 2: Cómo funciona el kernel Linux integrado en Windows</title><link>https://cmas.dev/posts/2025-01-07-internals-wsl-2/</link><pubDate>Tue, 07 Jan 2025 00:00:00 -0400</pubDate><guid>https://cmas.dev/posts/2025-01-07-internals-wsl-2/</guid><description>&lt;p>El Subsistema de Windows para Linux (WSL) ha transformado significativamente el desarrollo en entornos &lt;strong>Windows&lt;/strong>, permitiendo ejecutar distribuciones de Linux directamente en Windows sin necesidad de virtualización completa. Con &lt;strong>WSL 2&lt;/strong>, Microsoft introdujo un cambio radical: un kernel de Linux real corriendo sobre un sistema basado en hipervisor. En este artículo, exploraremos en detalle cómo funciona este kernel integrado y qué lo hace tan eficiente.&lt;/p>
&lt;h2 id="introducción-al-wsl-2">Introducción al WSL 2&lt;/h2>
&lt;p>WSL 2 es la segunda iteración del Subsistema de Windows para Linux. A diferencia de su predecesor (WSL 1), que traducía llamadas del sistema Linux a equivalentes de Windows, WSL 2 utiliza un kernel Linux completo. Esto lo hace más compatible y considerablemente más rápido en operaciones intensivas de E/S.&lt;/p>
&lt;h2 id="arquitectura-de-wsl-2">Arquitectura de WSL 2&lt;/h2>
&lt;p>WSL 2 introduce un cambio clave: utiliza una máquina virtual ligera basada en Hyper-V para ejecutar un kernel Linux real. A continuación, desglosamos los componentes principales:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Kernel Linux nativo&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>Microsoft compila un kernel Linux personalizado, optimizado para WSL.&lt;/li>
&lt;li>Este kernel se ejecuta en una máquina virtual ligera y recibe actualizaciones a través de Windows Update.&lt;/li>
&lt;li>Compatible con módulos y herramientas estándar de Linux.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Hyper-V como hipervisor&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>Hyper-V actúa como base para la virtualización.&lt;/li>
&lt;li>Utiliza tecnología de aislamiento para ejecutar el kernel de Linux en un entorno seguro y eficiente, sin el peso de una VM completa.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Interacción con Windows&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>A través de un sistema de integración, WSL 2 permite que Linux y Windows compartan recursos, como el sistema de archivos.&lt;/li>
&lt;li>Esto incluye acceso bidireccional al sistema de archivos, compatibilidad con puertos de red, y la capacidad de ejecutar comandos de Linux desde PowerShell o el símbolo del sistema.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="cómo-funciona-el-kernel-de-linux-en-wsl-2">Cómo funciona el kernel de Linux en WSL 2&lt;/h2>
&lt;p>El kernel de Linux en WSL 2 es la pieza clave que proporciona compatibilidad total con las distribuciones de Linux.&lt;/p>
&lt;h3 id="1-inicio-del-kernel">1. &lt;strong>Inicio del kernel&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>Al iniciar WSL 2, Windows lanza una instancia del kernel Linux en una máquina virtual ligera. Este proceso es extremadamente rápido, ya que la VM está optimizada para ser liviana y ejecutarse en segundo plano.&lt;/li>
&lt;li>El kernel es una compilación personalizada basada en la versión principal del kernel de Linux, asegurando compatibilidad con herramientas modernas.&lt;/li>
&lt;/ul>
&lt;h3 id="2-sistema-de-archivos">2. &lt;strong>Sistema de archivos&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>WSL 2 utiliza un sistema de archivos virtualizado para integrar Linux y Windows.&lt;/li>
&lt;li>El sistema de archivos de Windows (&lt;code>C:\&lt;/code>) se monta automáticamente dentro del entorno Linux en &lt;code>/mnt/c&lt;/code>.&lt;/li>
&lt;li>Las operaciones en archivos son mucho más rápidas gracias a la virtualización basada en bloques.&lt;/li>
&lt;/ul>
&lt;h3 id="3-interfaz-de-red">3. &lt;strong>Interfaz de red&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>El kernel Linux tiene acceso completo a una pila de red virtualizada.&lt;/li>
&lt;li>Puedes ejecutar servicios Linux y exponerlos a través de &lt;code>localhost&lt;/code> en Windows, lo que permite una integración perfecta con herramientas de desarrollo como servidores web.&lt;/li>
&lt;/ul>
&lt;h3 id="4-actualizaciones-del-kernel">4. &lt;strong>Actualizaciones del kernel&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>El kernel Linux en WSL 2 se actualiza automáticamente a través de Windows Update.&lt;/li>
&lt;li>Esto asegura que siempre tengas una versión segura y compatible sin necesidad de intervención manual.&lt;/li>
&lt;/ul>
&lt;h2 id="beneficios-técnicos-de-wsl-2">Beneficios técnicos de WSL 2&lt;/h2>
&lt;h3 id="mayor-rendimiento">Mayor rendimiento&lt;/h3>
&lt;p>El uso de un kernel Linux nativo elimina la necesidad de traducción de llamadas al sistema, lo que mejora significativamente el rendimiento en tareas como compilación de código o acceso al sistema de archivos.&lt;/p>
&lt;h3 id="compatibilidad-completa">Compatibilidad completa&lt;/h3>
&lt;p>WSL 2 es compatible con herramientas estándar de Linux como Docker, gracias a la implementación de características avanzadas como &lt;code>cgroups&lt;/code> y namespaces.&lt;/p>
&lt;h3 id="consumo-eficiente-de-recursos">Consumo eficiente de recursos&lt;/h3>
&lt;p>Aunque utiliza virtualización, WSL 2 es notablemente más liviano que las máquinas virtuales tradicionales. La VM de WSL 2 se adapta dinámicamente al uso de recursos, liberando memoria y CPU cuando no se necesita.&lt;/p>
&lt;h2 id="limitaciones-y-desafíos">Limitaciones y desafíos&lt;/h2>
&lt;p>A pesar de sus ventajas, WSL 2 tiene algunas limitaciones que deben tenerse en cuenta:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Requiere virtualización habilitada&lt;/strong>: WSL 2 depende de Hyper-V, por lo que no es compatible con sistemas donde no se puede habilitar la virtualización.&lt;/li>
&lt;li>&lt;strong>Compatibilidad con el sistema de archivos&lt;/strong>: Aunque es mucho más rápido que WSL 1, las operaciones en archivos alojados en Windows (&lt;code>/mnt/c&lt;/code>) pueden ser más lentas que en el sistema de archivos nativo de Linux.&lt;/li>
&lt;li>&lt;strong>Reinicio al cambiar configuraciones&lt;/strong>: Algunos cambios de configuración en WSL 2, como ajustes de memoria o CPU, requieren reiniciar la instancia.&lt;/li>
&lt;/ul>
&lt;h2 id="casos-prácticos">Casos prácticos&lt;/h2>
&lt;p>WSL 2 es ideal para:&lt;/p>
&lt;ul>
&lt;li>Ejecutar entornos de desarrollo Linux en Windows (Node.js, Python, Go, Ruby, etc.).&lt;/li>
&lt;li>Usar herramientas de línea de comandos de Linux, como &lt;code>grep&lt;/code>, &lt;code>awk&lt;/code> y &lt;code>sed&lt;/code>.&lt;/li>
&lt;li>Ejecutar contenedores Docker directamente en Windows sin necesidad de una VM completa.&lt;/li>
&lt;/ul>
&lt;h2 id="conclusión">Conclusión&lt;/h2>
&lt;p>&lt;strong>WSL 2&lt;/strong> representa un gran avance en la integración de &lt;strong>Linux&lt;/strong> y &lt;strong>Windows&lt;/strong>. Al utilizar un kernel Linux real y aprovechar la tecnología de virtualización de Hyper-V, ofrece un rendimiento y compatibilidad sin precedentes. Para desarrolladores que trabajan en entornos híbridos o que prefieren herramientas de Linux, WSL 2 es una solución imprescindible.&lt;/p></description></item><item><title>Benchmark de performance entre WSL2 y Hyper-V para cargas intensivas</title><link>https://cmas.dev/posts/2024-07-26-wsl2-performance-benchmark/</link><pubDate>Fri, 26 Jul 2024 00:00:00 -0400</pubDate><guid>https://cmas.dev/posts/2024-07-26-wsl2-performance-benchmark/</guid><description>&lt;p>&lt;strong>WSL2&lt;/strong> y &lt;strong>Hyper-V&lt;/strong> son tecnologías de virtualización de Microsoft que permiten ejecutar entornos Linux sobre Windows. Aunque WSL2 internamente utiliza Hyper-V, existen diferencias en cómo se gestionan los recursos, lo que puede impactar el rendimiento en tareas intensivas como compilación, procesamiento de datos o entrenamiento de modelos.&lt;/p>
&lt;p>Este artículo presenta un enfoque comparativo y práctico para medir el rendimiento de ambos entornos en escenarios de carga pesada.&lt;/p>
&lt;h2 id="objetivo">Objetivo&lt;/h2>
&lt;ul>
&lt;li>Comparar rendimiento de CPU, disco y memoria en WSL2 vs VM Hyper-V&lt;/li>
&lt;li>Ejecutar pruebas reproducibles con herramientas estándar&lt;/li>
&lt;li>Identificar ventajas y limitaciones de cada entorno según la carga&lt;/li>
&lt;/ul>
&lt;h2 id="preparación-del-entorno">Preparación del entorno&lt;/h2>
&lt;p>En ambos casos se utiliza Ubuntu 22.04 como sistema base, con los mismos paquetes y configuración.&lt;/p>
&lt;h3 id="para-wsl2">Para WSL2:&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">sudo apt update &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> sudo apt install -y sysbench stress-ng fio build-essential
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="para-hyper-v">Para Hyper-V:&lt;/h3>
&lt;ul>
&lt;li>Crear una máquina virtual con Ubuntu 22.04&lt;/li>
&lt;li>Asignar igual cantidad de CPU (por ejemplo, 4) y memoria (8 GB)&lt;/li>
&lt;li>Instalar los mismos paquetes para benchmark&lt;/li>
&lt;/ul>
&lt;h2 id="prueba-1-cpu-sysbench">Prueba 1: CPU (sysbench)&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">sysbench cpu --threads&lt;span class="o">=&lt;/span>&lt;span class="m">4&lt;/span> --time&lt;span class="o">=&lt;/span>&lt;span class="m">10&lt;/span> run
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Mide la cantidad de operaciones realizadas por segundo. Ejecutar la misma prueba en ambos entornos y anotar el throughput.&lt;/p>
&lt;h2 id="prueba-2-io-en-disco-fio">Prueba 2: I/O en disco (fio)&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">fio --name&lt;span class="o">=&lt;/span>seqwrite --size&lt;span class="o">=&lt;/span>512M --rw&lt;span class="o">=&lt;/span>write --bs&lt;span class="o">=&lt;/span>4k --numjobs&lt;span class="o">=&lt;/span>&lt;span class="m">1&lt;/span> --runtime&lt;span class="o">=&lt;/span>&lt;span class="m">30&lt;/span> --group_reporting
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Esta prueba mide el rendimiento de escritura secuencial. También se puede hacer con lectura (&lt;code>--rw=read&lt;/code>) o mezcla (&lt;code>--rw=randrw&lt;/code>).&lt;/p>
&lt;h2 id="prueba-3-memoria-stress-ng">Prueba 3: Memoria (stress-ng)&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">stress-ng --vm &lt;span class="m">2&lt;/span> --vm-bytes 1G --timeout 20s
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Simula presión de memoria con dos workers asignados a 1 GB cada uno.&lt;/p>
&lt;h2 id="prueba-4-compilación-intensiva">Prueba 4: Compilación intensiva&lt;/h2>
&lt;p>Clonar y compilar un proyecto grande, por ejemplo:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">git clone https://github.com/rust-lang/rust.git
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">cd&lt;/span> rust
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">./x.py build
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Comparar el tiempo de compilación completo.&lt;/p>
&lt;h2 id="resultados-esperados">Resultados esperados&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Prueba&lt;/th>
&lt;th>WSL2&lt;/th>
&lt;th>Hyper-V VM&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>CPU&lt;/td>
&lt;td>Similar&lt;/td>
&lt;td>Similar&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Disco (escritura)&lt;/td>
&lt;td>Mejor en Hyper-V*&lt;/td>
&lt;td>Peor en WSL2*&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>RAM (uso intensivo)&lt;/td>
&lt;td>Similar&lt;/td>
&lt;td>Similar&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Compilación&lt;/td>
&lt;td>Mejor en WSL2 (menos overhead de VM)&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>*El rendimiento de disco en WSL2 depende de si se trabaja dentro del FS Linux (&lt;code>~/&lt;/code>) o en &lt;code>/mnt/c/&lt;/code>, donde es mucho más lento.&lt;/p>
&lt;h2 id="buenas-prácticas-para-benchmarking">Buenas prácticas para benchmarking&lt;/h2>
&lt;ul>
&lt;li>Reiniciar ambos entornos antes de cada prueba&lt;/li>
&lt;li>Usar cronómetro o &lt;code>time&lt;/code> para medir duración total&lt;/li>
&lt;li>Evitar procesos en segundo plano que alteren los resultados&lt;/li>
&lt;li>Repetir pruebas y tomar promedio&lt;/li>
&lt;/ul>
&lt;h2 id="conclusión">Conclusión&lt;/h2>
&lt;p>WSL2 ofrece un excelente rendimiento para la mayoría de las cargas intensivas, con ventajas en integración con Windows y facilidad de uso. Hyper-V ofrece más aislamiento y control de hardware, con mejor I/O de disco en algunos casos. La elección depende del tipo de carga y necesidades específicas del entorno de trabajo.&lt;/p></description></item><item><title>Seguridad avanzada en WSL2: sandboxing y seccomp</title><link>https://cmas.dev/posts/2024-07-19-wsl2-advanced-security/</link><pubDate>Fri, 19 Jul 2024 00:00:00 -0400</pubDate><guid>https://cmas.dev/posts/2024-07-19-wsl2-advanced-security/</guid><description>&lt;p>WSL2, al ejecutar un kernel Linux completo dentro de Windows, hereda capacidades de seguridad del subsistema Linux y del entorno de Windows. Esto permite aplicar técnicas avanzadas como sandboxing y control de llamadas al sistema mediante &lt;code>seccomp&lt;/code>, protegiendo aplicaciones y conteniendo procesos potencialmente inseguros.&lt;/p>
&lt;h2 id="entendiendo-el-modelo-de-seguridad-de-wsl2">Entendiendo el modelo de seguridad de WSL2&lt;/h2>
&lt;ul>
&lt;li>WSL2 corre dentro de una VM ligera sobre Hyper-V&lt;/li>
&lt;li>Tiene su propio espacio de usuarios, red y sistema de archivos&lt;/li>
&lt;li>Puede acceder al sistema de archivos Windows, pero de forma controlada&lt;/li>
&lt;li>Hereda los permisos y restricciones del usuario de Windows anfitrión&lt;/li>
&lt;/ul>
&lt;p>Aunque no es un contenedor, se puede aplicar aislamiento similar con herramientas del ecosistema Linux.&lt;/p>
&lt;h2 id="usar-seccomp-para-limitar-llamadas-al-sistema">Usar seccomp para limitar llamadas al sistema&lt;/h2>
&lt;p>&lt;code>seccomp&lt;/code> permite definir qué llamadas al sistema (&lt;code>syscalls&lt;/code>) puede hacer un proceso. Esto es útil para bloquear funcionalidades peligrosas o limitar comportamientos.&lt;/p>
&lt;p>Instalar herramientas necesarias:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">sudo apt install -y seccomp libseccomp-dev strace
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Ejemplo de script bloqueando &lt;code>execve&lt;/code> (ejecución de procesos):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;linux/seccomp.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;linux/filter.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;linux/audit.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;sys/prctl.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;unistd.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">prctl&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">PR_SET_SECCOMP&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">SECCOMP_MODE_STRICT&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Hola, mundo seguro!&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">execl&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/bin/ls&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;ls&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// Esta llamada será bloqueada
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Compilar y ejecutar:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">gcc secure.c -o secure
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">./secure
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>El intento de ejecutar &lt;code>/bin/ls&lt;/code> fallará, mostrando que &lt;code>execve&lt;/code> fue bloqueado.&lt;/p>
&lt;h2 id="usar-firejail-para-sandboxing-de-procesos">Usar Firejail para sandboxing de procesos&lt;/h2>
&lt;p>&lt;strong>Firejail&lt;/strong> crea entornos aislados para correr procesos sin acceso a partes sensibles del sistema.&lt;/p>
&lt;p>Instalar:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">sudo apt install -y firejail
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Ejecutar un programa con aislamiento:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">firejail --private gedit
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Esto corre &lt;code>gedit&lt;/code> en un entorno aislado, sin acceso al home del usuario.&lt;/p>
&lt;p>Configurar perfiles personalizados para más control:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">firejail --profile&lt;span class="o">=&lt;/span>mi_perfil.profile programa
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="reforzar-seguridad-con-permisos-de-archivo">Reforzar seguridad con permisos de archivo&lt;/h2>
&lt;p>Aplicar técnicas tradicionales:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">chmod -R go-rwx ~/proyecto_secreto
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">chattr +i archivo.conf &lt;span class="c1"># Evita que sea modificado&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>También se pueden usar &lt;em>namespaces&lt;/em> y &lt;em>cgroups&lt;/em> para limitar CPU, RAM y accesos.&lt;/p>
&lt;h2 id="buenas-prácticas">Buenas prácticas&lt;/h2>
&lt;ul>
&lt;li>Usar usuarios no privilegiados por defecto&lt;/li>
&lt;li>Aislar procesos críticos con &lt;code>firejail&lt;/code> o seccomp&lt;/li>
&lt;li>Limitar accesos al sistema de archivos de Windows desde &lt;code>/mnt/c/&lt;/code>&lt;/li>
&lt;li>Auditar procesos con &lt;code>strace&lt;/code> o &lt;code>auditd&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="conclusión">Conclusión&lt;/h2>
&lt;p>WSL2 no solo ofrece potencia para desarrollo, sino también mecanismos de seguridad avanzados para proteger datos y procesos. Con herramientas como seccomp, Firejail y permisos reforzados, se puede alcanzar un alto nivel de aislamiento sin perder flexibilidad, incluso en entornos compartidos o productivos.&lt;/p></description></item><item><title>Nix + WSL2: gestión declarativa de entornos</title><link>https://cmas.dev/posts/2024-07-12-wsl2-nix/</link><pubDate>Fri, 12 Jul 2024 00:00:00 -0400</pubDate><guid>https://cmas.dev/posts/2024-07-12-wsl2-nix/</guid><description>&lt;p>&lt;strong>Nix&lt;/strong> es un sistema de gestión de paquetes y configuración que permite definir entornos de desarrollo de forma &lt;strong>declarativa y reproducible&lt;/strong>. Al combinar Nix con WSL2, se obtiene lo mejor de ambos mundos: control total sobre las dependencias y entornos aislados, con la eficiencia de Linux corriendo dentro de Windows.&lt;/p>
&lt;h2 id="por-qué-usar-nix-en-wsl2">Por qué usar Nix en WSL2&lt;/h2>
&lt;ul>
&lt;li>Configuración de entornos por proyecto&lt;/li>
&lt;li>Reproducibilidad exacta entre máquinas y desarrolladores&lt;/li>
&lt;li>Aislamiento sin necesidad de contenedores&lt;/li>
&lt;li>Compatibilidad total con herramientas Linux&lt;/li>
&lt;/ul>
&lt;p>Esto es especialmente útil en equipos, en proyectos de investigación, o en flujos DevOps que exigen entornos estables.&lt;/p>
&lt;h2 id="instalar-nix-en-wsl2">Instalar Nix en WSL2&lt;/h2>
&lt;p>Desde una terminal en Ubuntu o Debian:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">sh &amp;lt;&lt;span class="o">(&lt;/span>curl -L https://nixos.org/nix/install&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Al finalizar, activar el entorno:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">. ~/.nix-profile/etc/profile.d/nix.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Verificar:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">nix-env --version
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="crear-entorno-declarativo-con-shellnix">Crear entorno declarativo con &lt;code>shell.nix&lt;/code>&lt;/h2>
&lt;p>Ejemplo: entorno Python con NumPy y Pandas.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-nix" data-lang="nix">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># shell.nix&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span> &lt;span class="n">pkgs&lt;/span> &lt;span class="o">?&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="sr">&amp;lt;nixpkgs&amp;gt;&lt;/span> &lt;span class="p">{}&lt;/span> &lt;span class="p">}:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">pkgs&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">mkShell&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">buildInputs&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span> &lt;span class="n">pkgs&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">python310&lt;/span> &lt;span class="n">pkgs&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">python310Packages&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">numpy&lt;/span> &lt;span class="n">pkgs&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">python310Packages&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">pandas&lt;/span> &lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Activar el entorno:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">nix-shell
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Una vez dentro, las herramientas estarán disponibles sin afectar el sistema.&lt;/p>
&lt;h2 id="caso-práctico-entorno-para-ciencia-de-datos">Caso práctico: entorno para ciencia de datos&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-nix" data-lang="nix">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># shell.nix&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span> &lt;span class="n">pkgs&lt;/span> &lt;span class="o">?&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="sr">&amp;lt;nixpkgs&amp;gt;&lt;/span> &lt;span class="p">{}&lt;/span> &lt;span class="p">}:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">pkgs&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">mkShell&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;data-env&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">buildInputs&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">pkgs&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">python310&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">pkgs&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">python310Packages&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">numpy&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">pkgs&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">python310Packages&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">scipy&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">pkgs&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">python310Packages&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">matplotlib&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">pkgs&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">python310Packages&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">jupyter&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Iniciar:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">nix-shell
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">jupyter notebook
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Esto lanza un entorno Jupyter funcional desde WSL2.&lt;/p>
&lt;h2 id="buenas-prácticas">Buenas prácticas&lt;/h2>
&lt;ul>
&lt;li>Incluir &lt;code>shell.nix&lt;/code> en control de versiones&lt;/li>
&lt;li>Usar &lt;code>direnv&lt;/code> para cargar entornos automáticamente&lt;/li>
&lt;li>Combinar con &lt;code>lorri&lt;/code> o &lt;code>nix-direnv&lt;/code> para flujos más eficientes&lt;/li>
&lt;li>Actualizar paquetes vía &lt;code>nix-channel --update&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="conclusión">Conclusión&lt;/h2>
&lt;p>&lt;strong>Nix&lt;/strong> permite declarar entornos portables y estables para desarrollo, ciencia de datos o DevOps. Junto a WSL2, ofrece una solución poderosa para definir, compartir y automatizar configuraciones sin depender de contenedores o configuraciones globales, todo desde un entorno Linux dentro de Windows.&lt;/p></description></item><item><title>Desarrollo Rust en WSL2: toolchain, testing y empaquetado</title><link>https://cmas.dev/posts/2024-07-05-wsl2-rust-development/</link><pubDate>Fri, 05 Jul 2024 00:00:00 -0400</pubDate><guid>https://cmas.dev/posts/2024-07-05-wsl2-rust-development/</guid><description>&lt;p>&lt;strong>Rust&lt;/strong> es un lenguaje moderno y seguro por diseño, ideal para crear aplicaciones de alto rendimiento y sistemas embebidos. Combinado con WSL2, permite a los desarrolladores trabajar en un entorno &lt;strong>Linux&lt;/strong> desde &lt;strong>Windows&lt;/strong>, aprovechando herramientas como &lt;code>cargo&lt;/code>, &lt;code>rustup&lt;/code>, pruebas automatizadas y sistemas de empaquetado como &lt;code>cargo-deb&lt;/code>.&lt;/p>
&lt;h2 id="instalar-rust-en-wsl2">Instalar Rust en WSL2&lt;/h2>
&lt;p>Desde la terminal WSL2:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">curl --proto &lt;span class="s1">&amp;#39;=https&amp;#39;&lt;/span> --tlsv1.2 -sSf https://sh.rustup.rs &lt;span class="p">|&lt;/span> sh
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">source&lt;/span> &lt;span class="nv">$HOME&lt;/span>/.cargo/env
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Verificar la instalación:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">rustc --version
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cargo --version
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="crear-un-proyecto-rust-básico">Crear un proyecto Rust básico&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">cargo new mi_app
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">cd&lt;/span> mi_app
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cargo run
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Esto crea una estructura de proyecto estándar con &lt;code>Cargo.toml&lt;/code> y un archivo &lt;code>main.rs&lt;/code> en &lt;code>src/&lt;/code>.&lt;/p>
&lt;h2 id="usar-componentes-adicionales-del-toolchain">Usar componentes adicionales del toolchain&lt;/h2>
&lt;p>Instalar herramientas comunes:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">rustup component add clippy rustfmt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Verificar y formatear el código:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">cargo clippy
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cargo fmt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="escribir-y-ejecutar-tests-automatizados">Escribir y ejecutar tests automatizados&lt;/h2>
&lt;p>Agregar una función de prueba en &lt;code>src/lib.rs&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#[cfg(test)]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">mod&lt;/span> &lt;span class="nn">tests&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">use&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">super&lt;/span>::&lt;span class="o">*&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="cp">#[test]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">suma_funciona&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="fm">assert_eq!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Ejecutar tests:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">cargo &lt;span class="nb">test&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Se obtiene un resumen detallado del resultado, cobertura y errores si existen.&lt;/p>
&lt;h2 id="empaquetado-del-proyecto-con-cargo-deb">Empaquetado del proyecto con cargo-deb&lt;/h2>
&lt;p>Instalar herramienta para generar paquetes &lt;code>.deb&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">cargo install cargo-deb
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Empaquetar la aplicación:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">cargo deb
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Esto genera un archivo &lt;code>.deb&lt;/code> listo para distribuir e instalar en sistemas basados en Debian.&lt;/p>
&lt;h2 id="buenas-prácticas">Buenas prácticas&lt;/h2>
&lt;ul>
&lt;li>Usar &lt;code>cargo watch&lt;/code> para recompilar automáticamente al guardar cambios&lt;/li>
&lt;li>Separar lógica en módulos reutilizables dentro de &lt;code>src/&lt;/code>&lt;/li>
&lt;li>Mantener documentación con &lt;code>cargo doc --open&lt;/code>&lt;/li>
&lt;li>Publicar paquetes en crates.io solo si están documentados y testeados&lt;/li>
&lt;/ul>
&lt;h2 id="conclusión">Conclusión&lt;/h2>
&lt;p>Desarrollar con Rust en WSL2 brinda una experiencia fluida y potente, integrando el ecosistema Linux sin salir de Windows. Herramientas como &lt;code>cargo&lt;/code>, &lt;code>rustfmt&lt;/code>, &lt;code>clippy&lt;/code> y &lt;code>cargo-deb&lt;/code> permiten construir, probar y empaquetar software profesionalmente desde un entorno moderno y reproducible.&lt;/p></description></item><item><title>Compilación cruzada para Linux y Windows desde WSL2</title><link>https://cmas.dev/posts/2024-06-21-wsl2-cross-compiling/</link><pubDate>Fri, 21 Jun 2024 00:00:00 -0400</pubDate><guid>https://cmas.dev/posts/2024-06-21-wsl2-cross-compiling/</guid><description>&lt;p>Uno de los beneficios clave de WSL2 es la posibilidad de compilar binarios para Linux dentro de un entorno Linux completo, mientras se sigue trabajando desde Windows. Además, es posible configurar &lt;strong>compilación cruzada&lt;/strong> para generar ejecutables de Windows (&lt;code>.exe&lt;/code>) directamente desde WSL2, lo cual es útil para flujos de trabajo DevOps, empaquetado o testing multiplataforma.&lt;/p>
&lt;h3 id="-objetivo">🎯 Objetivo&lt;/h3>
&lt;ul>
&lt;li>Compilar aplicaciones para Linux directamente en WSL2&lt;/li>
&lt;li>Generar ejecutables &lt;code>.exe&lt;/code> de Windows desde WSL2 usando MinGW&lt;/li>
&lt;li>Compilar con CMake y Go para ambos entornos&lt;/li>
&lt;li>Automatizar la compilación multiplataforma&lt;/li>
&lt;/ul>
&lt;h2 id="-paso-1-preparar-entorno-de-compilación-en-wsl2">⚙️ Paso 1: Preparar entorno de compilación en WSL2&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">sudo apt update
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo apt install -y build-essential cmake mingw-w64 gcc g++ git
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Verificar toolchains:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">gcc --version
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">x86_64-w64-mingw32-gcc --version
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="-paso-2-compilar-binario-nativo-para-linux">🧪 Paso 2: Compilar binario nativo para Linux&lt;/h2>
&lt;p>Crear archivo &lt;code>hello.c&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Hola desde Linux&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Compilar:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">gcc hello.c -o hello-linux
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">./hello-linux
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="-paso-3-compilar-para-windows-exe-desde-wsl2">🪟 Paso 3: Compilar para Windows (.exe) desde WSL2&lt;/h2>
&lt;p>Usar MinGW para compilar en formato Windows:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">x86_64-w64-mingw32-gcc hello.c -o hello.exe
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Mover el binario a Windows:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">cp hello.exe /mnt/c/Users/tuusuario/Desktop/
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Ejecutar desde PowerShell:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-powershell" data-lang="powershell">&lt;span class="line">&lt;span class="cl">&lt;span class="n">C:&lt;/span>&lt;span class="p">\&lt;/span>&lt;span class="n">Users&lt;/span>&lt;span class="p">\&lt;/span>&lt;span class="n">tuusuario&lt;/span>&lt;span class="p">\&lt;/span>&lt;span class="n">Desktop&lt;/span>&lt;span class="p">\&lt;/span>&lt;span class="n">hello&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="py">exe&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="-paso-4-compilación-cruzada-con-cmake">🛠️ Paso 4: Compilación cruzada con CMake&lt;/h2>
&lt;p>Estructura de proyecto:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">miapp/
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">├── CMakeLists.txt
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">└── main.c
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>CMakeLists.txt:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cmake" data-lang="cmake">&lt;span class="line">&lt;span class="cl">&lt;span class="nb">cmake_minimum_required&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">VERSION&lt;/span> &lt;span class="s">3.10&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="nb">project&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">miapp&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="nb">add_executable&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">miapp&lt;/span> &lt;span class="s">main.c&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Build Linux:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">mkdir build-linux &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nb">cd&lt;/span> build-linux
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cmake ..
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">make
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Build Windows:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">mkdir build-win &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nb">cd&lt;/span> build-win
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cmake -DCMAKE_SYSTEM_NAME&lt;span class="o">=&lt;/span>Windows -DCMAKE_C_COMPILER&lt;span class="o">=&lt;/span>x86_64-w64-mingw32-gcc ..
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">make
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="-paso-5-compilar-con-go-para-ambos-entornos">💡 Paso 5: Compilar con Go para ambos entornos&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">sudo apt install -y golang
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Go detecta plataforma con variables &lt;code>GOOS&lt;/code> y &lt;code>GOARCH&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Linux nativo&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">go build -o hello-linux main.go
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Windows desde WSL2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">GOOS&lt;/span>&lt;span class="o">=&lt;/span>windows &lt;span class="nv">GOARCH&lt;/span>&lt;span class="o">=&lt;/span>amd64 go build -o hello.exe main.go
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="-conclusión">✅ Conclusión&lt;/h2>
&lt;p>WSL2 permite compilar aplicaciones para Linux y Windows sin salir del entorno de desarrollo, facilitando pruebas, empaquetado y automatización de builds multiplataforma. Con herramientas como MinGW, CMake y Go, es posible mantener un flujo productivo y coherente desde una única máquina.&lt;/p></description></item><item><title>Uso de WSLg: apps gráficas Linux en Windows con casos reales</title><link>https://cmas.dev/posts/2024-06-28-wsl2-wslg/</link><pubDate>Fri, 21 Jun 2024 00:00:00 -0400</pubDate><guid>https://cmas.dev/posts/2024-06-28-wsl2-wslg/</guid><description>&lt;p>WSLg (Windows Subsystem for Linux GUI) permite ejecutar aplicaciones gráficas de Linux directamente en Windows, sin necesidad de configurar un servidor X manualmente. Esta funcionalidad, incluida en WSL2 desde Windows 11, abre nuevas posibilidades para desarrolladores que utilizan herramientas Linux de escritorio como editores, simuladores, navegadores o visores de datos científicos.&lt;/p>
&lt;h2 id="qué-es-wslg">Qué es WSLg&lt;/h2>
&lt;p>WSLg es una capa que permite renderizar interfaces gráficas de aplicaciones Linux en el entorno Windows, utilizando una integración nativa de RDP (Remote Desktop Protocol) entre la VM de WSL2 y el host de Windows. No requiere instalación adicional en Windows 11.&lt;/p>
&lt;h2 id="verificar-que-wslg-esté-activo">Verificar que WSLg esté activo&lt;/h2>
&lt;p>Ejecutar una app gráfica como &lt;code>xeyes&lt;/code> o &lt;code>gedit&lt;/code> desde la terminal WSL2:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">sudo apt update
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo apt install -y x11-apps gedit
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">xeyes &lt;span class="p">&amp;amp;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">gedit &lt;span class="p">&amp;amp;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Si la ventana se muestra correctamente, WSLg está funcionando.&lt;/p>
&lt;h2 id="caso-real-visualización-de-datos-científicos">Caso real: Visualización de datos científicos&lt;/h2>
&lt;p>Instalar herramientas como &lt;code>matplotlib&lt;/code> o &lt;code>plotly&lt;/code> en Python y mostrar gráficos interactivos directamente desde Linux:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">pip install matplotlib
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Código de ejemplo:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">matplotlib.pyplot&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="nn">plt&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">plt&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">plot&lt;/span>&lt;span class="p">([&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">7&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">12&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">plt&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">title&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Gráfico de prueba en WSLg&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">plt&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">show&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>La ventana gráfica se abrirá automáticamente en Windows usando WSLg.&lt;/p>
&lt;h2 id="caso-real-uso-de-herramientas-gtk-o-qt">Caso real: Uso de herramientas GTK o Qt&lt;/h2>
&lt;p>Aplicaciones como GIMP, Inkscape, Kdenlive o editores como Geany se pueden instalar directamente desde el gestor de paquetes:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">sudo apt install -y gimp inkscape kdenlive geany
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Útiles para diseñadores, editores de video o usuarios que necesitan herramientas visuales sin salir del entorno Linux.&lt;/p>
&lt;h2 id="buenas-prácticas">Buenas prácticas&lt;/h2>
&lt;ul>
&lt;li>Usar una distro actualizada (Ubuntu 22.04 o superior)&lt;/li>
&lt;li>Evitar abrir decenas de ventanas para no saturar el canal RDP&lt;/li>
&lt;li>Asegurarse de tener aceleración gráfica habilitada (con &lt;code>glxinfo | grep &amp;quot;OpenGL renderer&amp;quot;&lt;/code>)&lt;/li>
&lt;li>Para rendimiento óptimo, correr apps que no demanden gráficos 3D complejos&lt;/li>
&lt;/ul>
&lt;h2 id="conclusión">Conclusión&lt;/h2>
&lt;p>WSLg extiende las capacidades de WSL2 al permitir ejecutar aplicaciones gráficas Linux de forma nativa en Windows. Esto simplifica flujos de trabajo mixtos, mejora la productividad y elimina la necesidad de usar máquinas virtuales o dual boot para tareas visuales o científicas complejas.&lt;/p></description></item><item><title>Deno, Go y Python en WSL2 para flujos mixtos de backend + AI</title><link>https://cmas.dev/posts/2024-06-14-wsl2-backend-ai/</link><pubDate>Fri, 14 Jun 2024 00:00:00 -0400</pubDate><guid>https://cmas.dev/posts/2024-06-14-wsl2-backend-ai/</guid><description>&lt;p>Combinar lenguajes modernos como &lt;strong>Deno&lt;/strong>, &lt;strong>Go&lt;/strong> y &lt;strong>Python&lt;/strong> permite crear soluciones backend de alto rendimiento con componentes de inteligencia artificial de forma modular y eficiente. Gracias a &lt;strong>WSL2&lt;/strong>, es posible configurar este stack en Linux desde Windows, integrando herramientas, librerías y entornos de ejecución en un mismo flujo de trabajo.&lt;/p>
&lt;h2 id="-objetivo">🎯 Objetivo&lt;/h2>
&lt;ul>
&lt;li>Instalar Deno, Go y Python en WSL2&lt;/li>
&lt;li>Ejecutar servidores backend ligeros con Deno y Go&lt;/li>
&lt;li>Usar Python para lógica de IA (modelo, predicción)&lt;/li>
&lt;li>Comunicar los componentes entre sí usando HTTP/REST&lt;/li>
&lt;/ul>
&lt;h2 id="-paso-1-instalar-entornos-en-wsl2">⚙️ Paso 1: Instalar entornos en WSL2&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Python&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo apt update &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> sudo apt install -y python3 python3-pip
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Go&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo apt install -y golang
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Deno&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">curl -fsSL https://deno.land/install.sh &lt;span class="p">|&lt;/span> sh
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;export DENO_INSTALL=&amp;#34;$HOME/.deno&amp;#34;&amp;#39;&lt;/span> &amp;gt;&amp;gt; ~/.bashrc
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;export PATH=&amp;#34;$DENO_INSTALL/bin:$PATH&amp;#34;&amp;#39;&lt;/span> &amp;gt;&amp;gt; ~/.bashrc
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">source&lt;/span> ~/.bashrc
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Verificar versiones:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">python3 --version
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">go version
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">deno --version
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="-paso-2-crear-backend-http-con-deno">🧪 Paso 2: Crear backend HTTP con Deno&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ts" data-lang="ts">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// api.ts
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kr">import&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">serve&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="kr">from&lt;/span> &lt;span class="s2">&amp;#34;https://deno.land/std@0.178.0/http/server.ts&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">serve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">req&lt;/span> &lt;span class="o">=&amp;gt;&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Response&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Hola desde Deno API&amp;#34;&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">port&lt;/span>: &lt;span class="kt">8000&lt;/span> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Ejecutar:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">deno run --allow-net api.ts
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="-paso-3-crear-servicio-go-para-procesamiento">⚙️ Paso 3: Crear servicio Go para procesamiento&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// server.go
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kn">package&lt;/span> &lt;span class="nx">main&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;net/http&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">HandleFunc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/go&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">w&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ResponseWriter&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">r&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Request&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Fprintf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">w&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;Hola desde Go service&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">})&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ListenAndServe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;:8080&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Compilar y correr:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">go run server.go
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="-paso-4-python-como-motor-de-ia">🤖 Paso 4: Python como motor de IA&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># model.py&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">flask&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">Flask&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">request&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">jsonify&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">numpy&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="nn">np&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">app&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Flask&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="vm">__name__&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@app.route&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;/predict&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">methods&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s1">&amp;#39;POST&amp;#39;&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">predict&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">request&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">json&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s1">&amp;#39;input&amp;#39;&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">pred&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">np&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">log1p&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># lógica simulada&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">jsonify&lt;/span>&lt;span class="p">({&lt;/span>&lt;span class="s1">&amp;#39;result&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">pred&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">tolist&lt;/span>&lt;span class="p">()})&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="vm">__name__&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s1">&amp;#39;__main__&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">app&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">run&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">port&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">5000&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Instalar dependencias y correr:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">pip install flask numpy
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">python3 model.py
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="-paso-5-comunicación-entre-servicios">🔗 Paso 5: Comunicación entre servicios&lt;/h2>
&lt;p>Desde Deno o Go se puede consumir el endpoint de Python:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">curl -X POST http://localhost:5000/predict -H &lt;span class="s2">&amp;#34;Content-Type: application/json&amp;#34;&lt;/span> -d &lt;span class="s1">&amp;#39;{&amp;#34;input&amp;#34;: [1, 2, 3]}&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Respuesta:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>&lt;span class="nt">&amp;#34;result&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mf">0.6931&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mf">1.0986&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mf">1.3862&lt;/span>&lt;span class="p">]}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="-conclusión">✅ Conclusión&lt;/h2>
&lt;p>Con WSL2 es posible combinar de forma eficiente lenguajes especializados para backend (Go, Deno) y lógica de IA (Python), manteniendo un entorno ligero y modular. Esta arquitectura híbrida mejora la productividad y facilita el mantenimiento en equipos multidisciplinarios que desarrollan APIs inteligentes.&lt;/p></description></item><item><title>Telemetría y monitoreo de procesos WSL2 con herramientas como Prometheus</title><link>https://cmas.dev/posts/2024-06-07-wsl2-prometheus/</link><pubDate>Fri, 07 Jun 2024 00:00:00 -0400</pubDate><guid>https://cmas.dev/posts/2024-06-07-wsl2-prometheus/</guid><description>&lt;p>El monitoreo de recursos y procesos es clave en cualquier entorno de desarrollo o pruebas. Gracias a la compatibilidad de WSL2 con herramientas Linux estándar, es posible usar soluciones de &lt;strong>observabilidad como Prometheus&lt;/strong> y &lt;strong>Node Exporter&lt;/strong> para visualizar el rendimiento del entorno WSL2 de forma clara y eficiente.&lt;/p>
&lt;h2 id="-objetivo">🎯 Objetivo&lt;/h2>
&lt;ul>
&lt;li>Exponer métricas del entorno Linux en WSL2&lt;/li>
&lt;li>Instalar y configurar &lt;strong>Node Exporter&lt;/strong>&lt;/li>
&lt;li>Usar &lt;strong>Prometheus&lt;/strong> para recolectar y visualizar métricas&lt;/li>
&lt;li>Explorar métricas útiles para desarrolladores y DevOps&lt;/li>
&lt;/ul>
&lt;h2 id="-paso-1-preparar-entorno-wsl2">⚙️ Paso 1: Preparar entorno WSL2&lt;/h2>
&lt;p>Instalar paquetes esenciales:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">sudo apt update &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> sudo apt install -y wget curl tar
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Crear carpeta de monitoreo:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">mkdir -p ~/monitoring &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nb">cd&lt;/span> ~/monitoring
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="-paso-2-instalar-node-exporter">📦 Paso 2: Instalar Node Exporter&lt;/h2>
&lt;p>Descargar binarios oficiales:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">wget https://github.com/prometheus/node_exporter/releases/download/v1.7.0/node_exporter-1.7.0.linux-amd64.tar.gz
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">tar xvf node_exporter-1.7.0.linux-amd64.tar.gz
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">cd&lt;/span> node_exporter-1.7.0.linux-amd64
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Ejecutar Node Exporter:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">./node_exporter
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Por defecto se expone en &lt;code>http://localhost:9100/metrics&lt;/code>&lt;/p>
&lt;h2 id="-paso-3-verificar-métricas">🔍 Paso 3: Verificar métricas&lt;/h2>
&lt;p>Acceder desde el navegador o con &lt;code>curl&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">curl http://localhost:9100/metrics &lt;span class="p">|&lt;/span> grep cpu
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Métricas disponibles incluyen:&lt;/p>
&lt;ul>
&lt;li>CPU usage&lt;/li>
&lt;li>Memory&lt;/li>
&lt;li>Disk I/O&lt;/li>
&lt;li>Network stats&lt;/li>
&lt;li>Load average&lt;/li>
&lt;/ul>
&lt;h2 id="-paso-4-configurar-prometheus-para-recolectar-datos">📈 Paso 4: Configurar Prometheus para recolectar datos&lt;/h2>
&lt;p>Crear archivo &lt;code>prometheus.yml&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">global&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">scrape_interval&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">5s&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">scrape_configs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">job_name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;wsl2-node&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">static_configs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">targets&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s1">&amp;#39;localhost:9100&amp;#39;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Descargar y ejecutar Prometheus:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">wget https://github.com/prometheus/prometheus/releases/download/v2.48.0/prometheus-2.48.0.linux-amd64.tar.gz
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">tar xvf prometheus-2.48.0.linux-amd64.tar.gz
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">cd&lt;/span> prometheus-2.48.0.linux-amd64
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">./prometheus --config.file&lt;span class="o">=&lt;/span>prometheus.yml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Interfaz disponible en &lt;code>http://localhost:9090&lt;/code>&lt;/p>
&lt;h2 id="-integración-con-docker-opcional">🛠️ Integración con Docker (opcional)&lt;/h2>
&lt;p>Se puede ejecutar &lt;strong>Node Exporter&lt;/strong> y &lt;strong>Prometheus&lt;/strong> como contenedores:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">docker run -d -p 9100:9100 --name node_exporter prom/node-exporter
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker run -d -p 9090:9090 -v &lt;span class="nv">$PWD&lt;/span>/prometheus.yml:/etc/prometheus/prometheus.yml prom/prometheus
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="-conclusión">✅ Conclusión&lt;/h2>
&lt;p>WSL2 permite monitorizar recursos de manera profesional usando herramientas estándar como &lt;strong>Prometheus&lt;/strong>. Esto es ideal para desarrolladores que necesitan observar el uso de CPU, RAM y procesos intensivos sin salir de su entorno &lt;strong>Windows&lt;/strong>, facilitando la implementación de prácticas &lt;strong>DevOps&lt;/strong> y &lt;strong>DataOps&lt;/strong>.&lt;/p></description></item><item><title>WSL2 como entorno para desarrollo MLOps</title><link>https://cmas.dev/posts/2024-05-31-wsl2-mlops/</link><pubDate>Fri, 31 May 2024 00:00:00 -0400</pubDate><guid>https://cmas.dev/posts/2024-05-31-wsl2-mlops/</guid><description>&lt;p>El ciclo de vida del machine learning moderno no solo involucra entrenar modelos, sino también automatizar, versionar y desplegar esos modelos en producción. Esto es lo que define el enfoque de &lt;strong>MLOps&lt;/strong>. Gracias a su compatibilidad con herramientas de Linux, contenedores, aceleración GPU y pipelines reproducibles, &lt;strong>WSL2 es ideal para este tipo de desarrollo desde Windows&lt;/strong>.&lt;/p>
&lt;h2 id="-objetivo">🎯 Objetivo&lt;/h2>
&lt;ul>
&lt;li>Crear un entorno de desarrollo MLOps usando WSL2&lt;/li>
&lt;li>Integrar herramientas como DVC, MLflow, Docker y Python&lt;/li>
&lt;li>Automatizar pipelines de entrenamiento y evaluación&lt;/li>
&lt;li>Ejecutar tareas reproducibles y escalables localmente&lt;/li>
&lt;/ul>
&lt;h2 id="-paso-1-preparar-entorno-base-en-wsl2">⚙️ Paso 1: Preparar entorno base en WSL2&lt;/h2>
&lt;p>Instalar Python y herramientas básicas:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">sudo apt update
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo apt install -y python3-pip python3-venv git
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">pip install --upgrade pip
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Clonar un proyecto de ejemplo o iniciar uno nuevo:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">git clone https://github.com/iterative/example-get-started-mlops.git
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cd example-get-started-mlops
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="-paso-2-instalar-dvc-para-control-de-datos-y-pipelines">🔁 Paso 2: Instalar DVC para control de datos y pipelines&lt;/h2>
&lt;p>&lt;a href="https://dvc.org/">DVC&lt;/a> es una herramienta fundamental en MLOps para manejar datos y etapas de procesamiento.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">pip install dvc[gs] dvc[ssh]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">dvc init
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Agregar un pipeline:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">dvc run -n preprocess -d src/preprocess.py -o data/processed python src/preprocess.py data/raw data/processed
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="-paso-3-automatizar-experimentos-con-mlflow">🧪 Paso 3: Automatizar experimentos con MLflow&lt;/h2>
&lt;p>Instalar MLflow:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">pip install mlflow
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Ejecutar un experimento:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">mlflow run .
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Lanzar la interfaz de MLflow:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">mlflow ui
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Ver resultados desde el navegador en &lt;code>http://localhost:5000&lt;/code>&lt;/p>
&lt;h2 id="-paso-4-contenerizar-el-flujo-con-docker">🐳 Paso 4: Contenerizar el flujo con Docker&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span class="line">&lt;span class="cl">&lt;span class="k">FROM&lt;/span>&lt;span class="s"> python:3.10-slim&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">WORKDIR&lt;/span>&lt;span class="s"> /app&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> . /app&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> pip install -r requirements.txt&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">ENTRYPOINT&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;python&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;src/train.py&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Construir y correr el contenedor:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">docker build -t mlops-model .
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker run --rm mlops-model
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="-buenas-prácticas-mlops-en-wsl2">🛠️ Buenas prácticas MLOps en WSL2&lt;/h2>
&lt;ul>
&lt;li>Usar &lt;code>make&lt;/code> para correr pipelines: &lt;code>make train&lt;/code>, &lt;code>make evaluate&lt;/code>&lt;/li>
&lt;li>Controlar recursos con &lt;code>.wslconfig&lt;/code>&lt;/li>
&lt;li>Versionar modelos con &lt;code>dvc push&lt;/code> y &lt;code>git tag&lt;/code>&lt;/li>
&lt;li>Integrar &lt;code>act&lt;/code> para correr GitHub Actions localmente&lt;/li>
&lt;li>Usar &lt;code>conda&lt;/code> o &lt;code>pip-tools&lt;/code> para entornos reproducibles&lt;/li>
&lt;/ul>
&lt;h2 id="-conclusión">✅ Conclusión&lt;/h2>
&lt;p>&lt;strong>WSL2&lt;/strong> permite construir un entorno completo de &lt;strong>MLOps&lt;/strong> directamente sobre &lt;strong>Windows&lt;/strong>, integrando control de versiones, contenedores, entrenamiento y despliegue en pipelines reproducibles. Es una solución ideal para equipos que necesitan compatibilidad con Linux pero prefieren trabajar desde Windows.&lt;/p></description></item><item><title>Automatización de tareas con Makefiles y Bash avanzado en WSL2</title><link>https://cmas.dev/posts/2024-05-24-wsl2-automation-makefiles-bash/</link><pubDate>Fri, 24 May 2024 00:00:00 -0400</pubDate><guid>https://cmas.dev/posts/2024-05-24-wsl2-automation-makefiles-bash/</guid><description>&lt;p>Una de las ventajas más potentes de WSL2 es la posibilidad de usar herramientas Linux como &lt;code>make&lt;/code> y Bash para automatizar tareas en proyectos de desarrollo, ciencia de datos, o DevOps. Este artículo detalla cómo crear scripts avanzados con Bash y cómo estructurar &lt;code>Makefiles&lt;/code> efectivos para ejecutar tareas complejas con un solo comando.&lt;/p>
&lt;h2 id="-objetivo">🎯 Objetivo&lt;/h2>
&lt;ul>
&lt;li>Crear scripts Bash reutilizables y robustos&lt;/li>
&lt;li>Diseñar &lt;code>Makefiles&lt;/code> para tareas como tests, builds o pipelines&lt;/li>
&lt;li>Integrar la automatización en entornos reproducibles bajo WSL2&lt;/li>
&lt;/ul>
&lt;h2 id="-paso-1-preparar-entorno-en-wsl2">⚙️ Paso 1: Preparar entorno en WSL2&lt;/h2>
&lt;p>Instalar dependencias básicas:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">sudo apt update &amp;amp;&amp;amp; sudo apt install -y make build-essential
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Organizar proyecto:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">mi-proyecto/
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">├── scripts/
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│ ├── build.sh
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│ └── test.sh
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">├── Makefile
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">└── README.md
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="-paso-2-crear-scripts-bash-reutilizables">🧪 Paso 2: Crear scripts Bash reutilizables&lt;/h2>
&lt;h3 id="buildsh">build.sh&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>&lt;span class="nb">set&lt;/span> -e
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;Compilando proyecto...&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">gcc src/main.c -o bin/app
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;Build completado con éxito.&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="testsh">test.sh&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>&lt;span class="nb">set&lt;/span> -e
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;Ejecutando tests...&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">pytest tests/
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Dar permisos de ejecución:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">chmod +x scripts/*.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="-paso-3-diseñar-un-makefile">📦 Paso 3: Diseñar un Makefile&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">.PHONY: build test clean all
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">build:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> bash scripts/build.sh
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">test:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> bash scripts/test.sh
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">clean:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> rm -rf bin/
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">all: clean build test
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Ahora se pueden ejecutar tareas fácilmente:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">make build
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">make test
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">make all
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="-paso-4-automatización-avanzada">🔁 Paso 4: Automatización avanzada&lt;/h2>
&lt;p>Agregar detección de entorno, logs o argumentos en los scripts:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>&lt;span class="nb">set&lt;/span> -e
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;Sistema operativo: &lt;/span>&lt;span class="k">$(&lt;/span>uname -a&lt;span class="k">)&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">DATE&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="k">$(&lt;/span>date +%Y-%m-%d&lt;span class="k">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">LOG&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;build_&lt;/span>&lt;span class="nv">$DATE&lt;/span>&lt;span class="s2">.log&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;Iniciando build...&amp;#34;&lt;/span> &lt;span class="p">|&lt;/span> tee &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="nv">$LOG&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">gcc src/main.c -o bin/app &amp;gt;&amp;gt; &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="nv">$LOG&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span> 2&amp;gt;&lt;span class="p">&amp;amp;&lt;/span>&lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>O usar variables en &lt;code>Makefile&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">DATE := $(shell date +%F)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">LOGFILE := logs/build_$(DATE).log
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">logbuild:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> mkdir -p logs
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> bash scripts/build.sh | tee $(LOGFILE)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="-buenas-prácticas">🛠️ Buenas prácticas&lt;/h2>
&lt;ul>
&lt;li>Validar argumentos (&lt;code>&amp;quot;$#&amp;quot;&lt;/code> y &lt;code>&amp;quot;$1&amp;quot;&lt;/code>) en scripts&lt;/li>
&lt;li>Documentar cada tarea con comentarios o &lt;code>README.md&lt;/code>&lt;/li>
&lt;li>Usar &lt;code>.PHONY&lt;/code> para evitar conflictos con archivos&lt;/li>
&lt;li>Versionar scripts y &lt;code>Makefile&lt;/code> en Git para control de cambios&lt;/li>
&lt;/ul>
&lt;h2 id="-conclusión">✅ Conclusión&lt;/h2>
&lt;p>Con Bash avanzado y Makefiles bien diseñados, es posible automatizar completamente tareas comunes de desarrollo en WSL2, mejorando la productividad, reduciendo errores y asegurando reproducibilidad en equipos o entornos compartidos.&lt;/p></description></item><item><title>VS Code Remote WSL para flujos de trabajo Data Science</title><link>https://cmas.dev/posts/2024-05-17-wsl2-remote-data-science/</link><pubDate>Fri, 17 May 2024 00:00:00 -0400</pubDate><guid>https://cmas.dev/posts/2024-05-17-wsl2-remote-data-science/</guid><description>&lt;p>El desarrollo de proyectos de ciencia de datos desde Windows puede beneficiarse enormemente del uso de &lt;strong>WSL2 con VS Code Remote&lt;/strong>. Esta combinación permite aprovechar herramientas y entornos Linux directamente desde el editor, manteniendo la flexibilidad de Windows en tareas cotidianas como análisis, visualización o modelado de datos.&lt;/p>
&lt;h2 id="-objetivo">🎯 Objetivo&lt;/h2>
&lt;ul>
&lt;li>Configurar un entorno Linux para ciencia de datos dentro de WSL2&lt;/li>
&lt;li>Integrarlo con &lt;strong>Visual Studio Code&lt;/strong> mediante la extensión &lt;strong>Remote - WSL&lt;/strong>&lt;/li>
&lt;li>Usar Jupyter Notebooks, entornos virtuales y bibliotecas científicas desde VS Code&lt;/li>
&lt;li>Trabajar con flujos reproducibles usando pip, conda y notebooks&lt;/li>
&lt;/ul>
&lt;h2 id="-requisitos-previos">🧰 Requisitos previos&lt;/h2>
&lt;ul>
&lt;li>Windows 10/11 con WSL2 activado&lt;/li>
&lt;li>Distro Linux instalada (Ubuntu 22.04 recomendado)&lt;/li>
&lt;li>VS Code con la extensión &lt;strong>Remote - WSL&lt;/strong>&lt;/li>
&lt;li>Python 3, pip y/o conda&lt;/li>
&lt;/ul>
&lt;h2 id="-paso-1-instalar-dependencias-en-la-distro-wsl2">⚙️ Paso 1: Instalar dependencias en la distro WSL2&lt;/h2>
&lt;p>Desde tu terminal WSL:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">sudo apt update &amp;amp;&amp;amp; sudo apt upgrade -y
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo apt install -y python3-pip python3-venv git
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Instalar bibliotecas de ciencia de datos:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">pip install numpy pandas matplotlib seaborn scikit-learn jupyter
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Opcional: usar &lt;code>miniconda&lt;/code> si se prefiere conda como gestor de entornos.&lt;/p>
&lt;h2 id="-paso-2-abrir-wsl-desde-vs-code">💻 Paso 2: Abrir WSL desde VS Code&lt;/h2>
&lt;ol>
&lt;li>Abrí &lt;strong>VS Code&lt;/strong>&lt;/li>
&lt;li>Presioná &lt;code>Ctrl+Shift+P&lt;/code> y escribí: &lt;code>Remote-WSL: New Window&lt;/code>&lt;/li>
&lt;li>Seleccioná tu distribución (ej: Ubuntu)&lt;/li>
&lt;/ol>
&lt;p>Ahora estás en una sesión remota con acceso completo a la terminal, Python, Jupyter y entorno Linux desde el editor.&lt;/p>
&lt;h2 id="-paso-3-usar-jupyter-notebooks-dentro-de-vs-code">📓 Paso 3: Usar Jupyter Notebooks dentro de VS Code&lt;/h2>
&lt;p>Instalar extensión oficial de &lt;strong>Jupyter&lt;/strong> en VS Code.&lt;/p>
&lt;p>Crear un nuevo notebook (&lt;code>.ipynb&lt;/code>) y seleccioná el kernel Python correspondiente desde el entorno WSL.&lt;/p>
&lt;p>Verificá que ejecutás en WSL:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">import platform
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">print(platform.system(), platform.release())
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="-ejemplo-práctico-análisis-exploratorio">🧪 Ejemplo práctico: Análisis exploratorio&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span class="line">&lt;span class="cl">&lt;span class="n">import&lt;/span> &lt;span class="n">pandas&lt;/span> &lt;span class="n">as&lt;/span> &lt;span class="n">pd&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">import&lt;/span> &lt;span class="n">seaborn&lt;/span> &lt;span class="n">as&lt;/span> &lt;span class="n">sns&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">import&lt;/span> &lt;span class="n">matplotlib&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">pyplot&lt;/span> &lt;span class="n">as&lt;/span> &lt;span class="n">plt&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">df&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">sns&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">load_dataset&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;penguins&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">sns&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">pairplot&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">df&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">hue&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;species&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">plt&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">show&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Este script corre directamente en el entorno WSL, usando la GPU (si está disponible), y sin overhead de traducción de entornos.&lt;/p>
&lt;h2 id="-buenas-prácticas">🛠️ Buenas prácticas&lt;/h2>
&lt;ul>
&lt;li>Guardar los proyectos en el sistema de archivos Linux (&lt;code>~/proyectos&lt;/code>, no en &lt;code>/mnt/c/&lt;/code>) para mayor rendimiento&lt;/li>
&lt;li>Usar entornos virtuales (&lt;code>python3 -m venv .venv&lt;/code>) para evitar conflictos&lt;/li>
&lt;li>Versionar notebooks y scripts con Git (&lt;code>git init&lt;/code>)&lt;/li>
&lt;li>Añadir &lt;code>requirements.txt&lt;/code> para reproducibilidad:&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">pip freeze &amp;gt; requirements.txt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="-conclusión">✅ Conclusión&lt;/h2>
&lt;p>&lt;strong>VS Code&lt;/strong> + R&lt;strong>emote WSL&lt;/strong> ofrece una experiencia fluida para la ciencia de datos en &lt;strong>Windows&lt;/strong>, combinando la potencia de &lt;strong>Linux&lt;/strong> con la comodidad de un entorno gráfico moderno. Con Jupyter, Python y bibliotecas científicas listas para usar, es posible construir, visualizar y entrenar modelos de manera productiva, eficiente y reproducible.&lt;/p></description></item><item><title>WSL2 + NVIDIA GPU: configuración óptima para workloads de IA</title><link>https://cmas.dev/posts/2024-05-10-wsl2-nvidia-gpu/</link><pubDate>Fri, 10 May 2024 00:00:00 -0400</pubDate><guid>https://cmas.dev/posts/2024-05-10-wsl2-nvidia-gpu/</guid><description>&lt;p>Desde mediados de 2020, WSL2 ofrece soporte oficial para &lt;strong>aceleración por GPU con NVIDIA&lt;/strong>. Esto permite ejecutar frameworks como &lt;strong>[PyTorch]&lt;/strong>(&lt;a href="https://pytorch.org/get-started/locally/">https://pytorch.org/get-started/locally/&lt;/a>) o &lt;strong>TensorFlow&lt;/strong> con &lt;strong>[CUDA]&lt;/strong>(&lt;a href="https://docs.nvidia.com/cuda/wsl-user-guide/index.html">https://docs.nvidia.com/cuda/wsl-user-guide/index.html&lt;/a>) directamente desde &lt;strong>Linux&lt;/strong> en &lt;strong>Windows&lt;/strong>, ideal para tareas de entrenamiento y prueba de modelos de inteligencia artificial.&lt;/p>
&lt;h2 id="-objetivo">🎯 Objetivo&lt;/h2>
&lt;p>Configurar un entorno de desarrollo basado en WSL2 con soporte GPU, incluyendo:&lt;/p>
&lt;ul>
&lt;li>Acceso a GPU NVIDIA desde el subsistema Linux&lt;/li>
&lt;li>Instalación de CUDA Toolkit y cuDNN&lt;/li>
&lt;li>Ejecución de scripts con PyTorch y verificación del entorno&lt;/li>
&lt;li>Prácticas recomendadas para aprovechar la aceleración por hardware&lt;/li>
&lt;/ul>
&lt;h2 id="-requisitos-previos">🧰 Requisitos previos&lt;/h2>
&lt;ul>
&lt;li>Windows 11 (o Windows 10 21H2 en adelante)&lt;/li>
&lt;li>WSL2 instalado y actualizado (&lt;code>wsl --update&lt;/code>)&lt;/li>
&lt;li>GPU NVIDIA compatible (preferentemente RTX)&lt;/li>
&lt;li>Driver de GPU actualizado: &lt;a href="https://www.nvidia.com/Download/index.aspx">nvidia.com/Download&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Verificación del entorno desde PowerShell:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">nvidia-smi
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="-paso-1-activar-wsl2-con-soporte-gpu">⚙️ Paso 1: Activar WSL2 con soporte GPU&lt;/h2>
&lt;p>Instalar WSL y una distribución como Ubuntu 22.04:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">wsl --install -d Ubuntu
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Actualizar WSL a la última versión:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">wsl --update
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">wsl --shutdown
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="-paso-2-instalar-cuda-y-herramientas-base-en-wsl2">🚀 Paso 2: Instalar CUDA y herramientas base en WSL2&lt;/h2>
&lt;p>Desde la terminal Linux en WSL2:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">sudo apt update &amp;amp;&amp;amp; sudo apt upgrade -y
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo apt install -y build-essential dkms
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Agregar repositorios oficiales de NVIDIA:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span class="line">&lt;span class="cl">&lt;span class="n">distribution&lt;/span>&lt;span class="o">=$&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">.&lt;/span> &lt;span class="o">/&lt;/span>&lt;span class="n">etc&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">os&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">release&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">echo&lt;/span> &lt;span class="o">$&lt;/span>&lt;span class="n">ID&lt;/span>&lt;span class="o">$&lt;/span>&lt;span class="n">VERSION_ID&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">curl&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">s&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">L&lt;/span> &lt;span class="n">https&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="n">nvidia&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">github&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">io&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">libnvidia&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">container&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">gpgkey&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="n">sudo&lt;/span> &lt;span class="n">apt&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">key&lt;/span> &lt;span class="n">add&lt;/span> &lt;span class="o">-&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">curl&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">s&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">L&lt;/span> &lt;span class="n">https&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="n">nvidia&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">github&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">io&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">libnvidia&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">container&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">ubuntu&lt;/span>&lt;span class="o">$&lt;/span>&lt;span class="n">distribution&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">libnvidia&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">container&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">list&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="n">sudo&lt;/span> &lt;span class="n">tee&lt;/span> &lt;span class="o">/&lt;/span>&lt;span class="n">etc&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">apt&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">sources&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">list&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">d&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">nvidia&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">container&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">list&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">sudo&lt;/span> &lt;span class="n">apt&lt;/span> &lt;span class="n">update&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">sudo&lt;/span> &lt;span class="n">apt&lt;/span> &lt;span class="n">install&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">y&lt;/span> &lt;span class="n">nvidia&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">driver&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">535&lt;/span> &lt;span class="n">nvidia&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">cuda&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">toolkit&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="-paso-3-verificar-acceso-a-la-gpu-desde-wsl2">🧪 Paso 3: Verificar acceso a la GPU desde WSL2&lt;/h2>
&lt;p>Dentro del entorno WSL2:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">nvidia-smi
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>El sistema debe mostrar la tarjeta gráfica, memoria y uso actual.&lt;/p>
&lt;h2 id="-paso-4-instalar-pytorch-con-soporte-cuda">🧠 Paso 4: Instalar PyTorch con soporte CUDA&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span class="line">&lt;span class="cl">&lt;span class="n">pip&lt;/span> &lt;span class="n">install&lt;/span> &lt;span class="n">torch&lt;/span> &lt;span class="n">torchvision&lt;/span> &lt;span class="n">torchaudio&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">url&lt;/span> &lt;span class="n">https&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="n">download&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">pytorch&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">org&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">whl&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">cu118&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Verificar el acceso a la GPU desde un script:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">import torch
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">print(&amp;#34;CUDA disponible:&amp;#34;, torch.cuda.is_available())
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">print(&amp;#34;GPU:&amp;#34;, torch.cuda.get_device_name(0))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="-solución-de-problemas-comunes">🛠️ Solución de problemas comunes&lt;/h2>
&lt;ul>
&lt;li>Si &lt;code>nvidia-smi&lt;/code> no detecta la GPU, asegurarse de tener los drivers y WSL actualizados.&lt;/li>
&lt;li>No se recomienda instalar CUDA directamente desde la web de NVIDIA; es preferible utilizar los repos oficiales para WSL.&lt;/li>
&lt;li>Es importante reiniciar el entorno después de cambios: &lt;code>wsl --shutdown&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="-buenas-prácticas">📈 Buenas prácticas&lt;/h2>
&lt;ul>
&lt;li>Utilizar distribuciones ligeras como Debian o Ubuntu minimal para reducir el uso de recursos.&lt;/li>
&lt;li>Configurar límites de recursos en &lt;code>.wslconfig&lt;/code> si se comparte la GPU con otros procesos.&lt;/li>
&lt;li>Monitorear la temperatura y uso con &lt;code>nvidia-smi&lt;/code>.&lt;/li>
&lt;li>Emplear &lt;code>tmux&lt;/code> o &lt;code>screen&lt;/code> para mantener tareas de entrenamiento corriendo en segundo plano.&lt;/li>
&lt;/ul>
&lt;h2 id="-conclusión">✅ Conclusión&lt;/h2>
&lt;p>Configurar &lt;strong>WSL2&lt;/strong> con acceso a &lt;strong>GPU NVIDIA&lt;/strong> representa una alternativa práctica y poderosa para ejecutar flujos de trabajo de &lt;strong>IA&lt;/strong> desde un entorno &lt;strong>Linux&lt;/strong> en &lt;strong>Windows&lt;/strong>. Esta solución permite acelerar el desarrollo y pruebas de modelos, aprovechando la compatibilidad de herramientas modernas con &lt;strong>CUDA&lt;/strong> y &lt;strong>PyTorch&lt;/strong>.&lt;/p></description></item><item><title>Uso de systemd en WSL2: servicios persistentes y supervisión</title><link>https://cmas.dev/posts/2024-05-03-wsl2-systemd/</link><pubDate>Fri, 03 May 2024 00:00:00 -0400</pubDate><guid>https://cmas.dev/posts/2024-05-03-wsl2-systemd/</guid><description>&lt;p>Desde 2022, &lt;strong>WSL2&lt;/strong> incluye soporte para &lt;code>systemd&lt;/code>, el sistema de inicialización y gestión de servicios usado en la mayoría de las distros &lt;strong>Linux&lt;/strong> modernas. Esto habilita la ejecución de servicios persistentes, como &lt;code>ssh&lt;/code>, &lt;code>postgresql&lt;/code> o &lt;code>docker&lt;/code>, directamente en el entorno &lt;strong>WSL2&lt;/strong>&amp;hellip;&lt;/p>
&lt;h2 id="-activar-systemd-en-wsl2">⚙️ Activar systemd en WSL2&lt;/h2>
&lt;ol>
&lt;li>Asegurarse de tener WSL actualizado:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">wsl --update
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>Editar el archivo &lt;code>/etc/wsl.conf&lt;/code> en la distro:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">[boot]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">systemd=true
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>Cerrar todas las instancias WSL y ejecutar:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">wsl --shutdown
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="4">
&lt;li>Verificar que systemd esté activo:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">systemctl list-units --type=service
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="-ejecutar-servicios">🧪 Ejecutar servicios&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">sudo systemctl enable postgresql
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo systemctl start postgresql
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>También se puede usar &lt;code>journalctl&lt;/code> para logs persistentes:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">journalctl -xe
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="-consideraciones">🔒 Consideraciones&lt;/h2>
&lt;ul>
&lt;li>Algunas distros necesitan reconfigurar permisos o reinstalar servicios tras activar systemd.&lt;/li>
&lt;li>&lt;code>sudo&lt;/code> se vuelve más importante para manejar correctamente el árbol de procesos.&lt;/li>
&lt;/ul>
&lt;h2 id="-conclusión">✅ Conclusión&lt;/h2>
&lt;p>Con &lt;strong>systemd&lt;/strong> habilitado en &lt;strong>WSL2&lt;/strong>, se puede correr y supervisar servicios como si estuviera en un servidor &lt;strong>Linux&lt;/strong> real. Esto hace que &lt;strong>WSL2&lt;/strong> sea una herramienta aún más poderosa para flujos &lt;strong>DevOps&lt;/strong>, testing y desarrollo backend.&lt;/p></description></item><item><title>Integración avanzada con Docker Desktop y contenedores cruzados</title><link>https://cmas.dev/posts/2024-04-25-wsl2-docker-integration/</link><pubDate>Thu, 25 Apr 2024 00:00:00 -0400</pubDate><guid>https://cmas.dev/posts/2024-04-25-wsl2-docker-integration/</guid><description>&lt;p>&lt;strong>Docker&lt;/strong> y &lt;strong>WSL2&lt;/strong> trabajan juntos de forma nativa desde 2020. &lt;strong>Docker Desktop&lt;/strong> para &lt;strong>Windows&lt;/strong> ahora se basa completamente en &lt;strong>WSL2&lt;/strong>, permitiendo ejecutar contenedores &lt;strong>Linux&lt;/strong> sin la necesidad de &lt;strong>Hyper-V&lt;/strong> por separado.&lt;/p>
&lt;h2 id="-cómo-funciona-docker-con-wsl2">🐳 Cómo funciona Docker con WSL2&lt;/h2>
&lt;p>&lt;strong>Docker&lt;/strong> instala una distro especial llamada &lt;code>docker-desktop&lt;/code> que actúa como backend de ejecución.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">wsl --list --verbose
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># Deberías ver:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># docker-desktop
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># docker-desktop-data
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="-activar-integración-con-tu-distro">🛠️ Activar integración con tu distro&lt;/h2>
&lt;p>Desde &lt;strong>Docker Desktop&lt;/strong> → &lt;strong>Settings&lt;/strong> → &lt;strong>Resources&lt;/strong> → &lt;strong>WSL Integration&lt;/strong>&lt;/p>
&lt;p>Habilitá tu distro personalizada (Ubuntu, Debian, etc.).&lt;/p>
&lt;p>Una vez activada, podés correr Docker directamente:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">docker run --rm alpine echo &amp;#34;Hola desde Alpine en WSL2&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="-contenedores-cruzados-windows--linux">🔄 Contenedores cruzados (Windows ↔ Linux)&lt;/h2>
&lt;p>Si activás también la integración de &lt;strong>Docker Desktop&lt;/strong> con &lt;strong>PowerShell&lt;/strong>, podés correr contenedores &lt;strong>Linux&lt;/strong> desde &lt;strong>Windows&lt;/strong> y viceversa.&lt;/p>
&lt;h3 id="ejemplo-build-en-wsl2-deploy-desde-windows">Ejemplo: build en WSL2, deploy desde Windows&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># WSL2: construir imagen&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">docker&lt;/span> &lt;span class="n">build&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">t&lt;/span> &lt;span class="n">myapp&lt;/span> &lt;span class="o">.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Windows: ejecutar desde PowerShell&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">docker&lt;/span> &lt;span class="n">run&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="n">rm&lt;/span> &lt;span class="n">myapp&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="-conclusión">✅ Conclusión&lt;/h2>
&lt;p>&lt;strong>WSL2&lt;/strong> + &lt;strong>Docker Desktop&lt;/strong> brinda un entorno potente para desarrollo con contenedores, permitiendo compartir imágenes y redes entre sistemas. Esta integración elimina muchas barreras y mejora la productividad para desarrolladores de backend, DevOps y microservicios.&lt;/p></description></item><item><title>Gestión avanzada de múltiples distros en WSL2</title><link>https://cmas.dev/posts/2024-04-19-wsl2-multiple-distros/</link><pubDate>Fri, 19 Apr 2024 00:00:00 -0400</pubDate><guid>https://cmas.dev/posts/2024-04-19-wsl2-multiple-distros/</guid><description>&lt;p>Una de las grandes ventajas de WSL2 es la posibilidad de instalar y ejecutar múltiples distribuciones de Linux simultáneamente, cada una con su propio sistema de archivos, paquetes y configuraciones.&lt;/p>
&lt;h2 id="-listar-distros-disponibles">🔍 Listar distros disponibles&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">wsl --list --verbose
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Esto muestra las distros instaladas, su estado actual y versión de WSL (1 o 2).&lt;/p>
&lt;h2 id="-instalar-múltiples-distros">📦 Instalar múltiples distros&lt;/h2>
&lt;p>Desde Microsoft Store o usando una imagen &lt;code>.tar&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">wsl --import Debian-Dev D:\WSL\Debian-Dev debian-rootfs.tar
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="-crear-un-backup-de-una-distro">🛠️ Crear un backup de una distro&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span class="line">&lt;span class="cl">&lt;span class="n">wsl&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="k">export&lt;/span> &lt;span class="n">Ubuntu&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">Dev&lt;/span> &lt;span class="n">ubuntu&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">dev&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">backup&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">tar&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="-restaurar-o-clonar-una-distro">🔄 Restaurar o clonar una distro&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">wsl --import Ubuntu-Clon D:\WSL\Ubuntu-Clon ubuntu-dev-backup.tar
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="-sincronizar-configuraciones">🔁 Sincronizar configuraciones&lt;/h2>
&lt;p>Se puede mantener las configuraciones con &lt;code>dotfiles&lt;/code>, scripts de provisión o herramientas como Ansible o chezmoi.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl"># Ejemplo simple con Git
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git clone https://github.com/tuusuario/dotfiles ~/.dotfiles
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">bash ~/.dotfiles/setup.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="-automatización-de-flujos-entre-distros">⚙️ Automatización de flujos entre distros&lt;/h2>
&lt;p>Usar scripts Bash para pasar configuraciones, instalar paquetes o incluso ejecutar pruebas cruzadas entre distros.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">for distro in Ubuntu-Dev Debian-Dev; do
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> wsl -d $distro -- bash -c &amp;#34;sudo apt update &amp;amp;&amp;amp; sudo apt upgrade -y&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">done
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="-conclusión">✅ Conclusión&lt;/h2>
&lt;p>Gestionar múltiples distros con WSL2 permite aislar entornos, probar configuraciones específicas o crear pipelines DevOps más robustos. Con herramientas de exportación, scripting y dotfiles, se puede mantener un stack alineado en todos los equipos o contextos.&lt;/p></description></item><item><title>Automatización avanzada de distros WSL2 con wsl.conf y cloud-init</title><link>https://cmas.dev/posts/2024-04-12-wsl2-advanced-distro-automation/</link><pubDate>Fri, 12 Apr 2024 00:00:00 -0400</pubDate><guid>https://cmas.dev/posts/2024-04-12-wsl2-advanced-distro-automation/</guid><description>&lt;p>Uno de los beneficios clave de &lt;strong>WSL2&lt;/strong> es la capacidad de automatizar la configuración del entorno Linux que corre sobre Windows. Esto permite establecer comportamientos predefinidos y provisionar distros listas para el trabajo sin intervención manual. En este artículo exploramos dos mecanismos clave: &lt;code>wsl.conf&lt;/code> y &lt;code>cloud-init&lt;/code>.&lt;/p>
&lt;h2 id="-qué-es-wslconf">⚙️ ¿Qué es &lt;code>wsl.conf&lt;/code>?&lt;/h2>
&lt;p>Es un archivo de configuración ubicado en &lt;code>/etc/wsl.conf&lt;/code> dentro de cada distro. Permite modificar cómo WSL monta discos, configura redes y gestiona el entorno.&lt;/p>
&lt;h3 id="ejemplo-básico">Ejemplo básico:&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">[automount]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">enabled = true
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">root = /mnt/
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">options = &amp;#34;metadata,umask=22,fmask=11&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">[network]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">generateResolvConf = false
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">[user]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">default = devuser
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>Monta unidades de Windows con metadatos de permisos.&lt;/li>
&lt;li>Previene conflictos DNS con &lt;code>resolv.conf&lt;/code>.&lt;/li>
&lt;li>Define el usuario predeterminado al iniciar la terminal.&lt;/li>
&lt;/ul>
&lt;p>✅ Ideal para escenarios donde múltiples usuarios usan la misma distro o cuando se quiere mantener un entorno consistente.&lt;/p>
&lt;h2 id="-qué-es-cloud-init">☁️ ¿Qué es &lt;code>cloud-init&lt;/code>?&lt;/h2>
&lt;p>Originalmente pensado para entornos cloud como EC2 o Azure VM, &lt;code>cloud-init&lt;/code> también funciona en algunas distros WSL2 (por ejemplo, Ubuntu). Permite definir:&lt;/p>
&lt;ul>
&lt;li>Paquetes a instalar&lt;/li>
&lt;li>Archivos de configuración&lt;/li>
&lt;li>Comandos post-instalación&lt;/li>
&lt;li>Creación de usuarios&lt;/li>
&lt;/ul>
&lt;h3 id="ejemplo-yaml">Ejemplo YAML:&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl"># /etc/cloud/cloud.cfg.d/01-wsl-autoconfig.cfg
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">packages:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> - git
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> - zsh
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> - build-essential
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">runcmd:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> - echo &amp;#34;WSL2 provisionado automáticamente&amp;#34; &amp;gt;&amp;gt; /etc/motd
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> - chsh -s $(which zsh) devuser
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="activación">Activación:&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">sudo cloud-init init
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo cloud-init status --long
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>🧠 Tip: Se puede combinar esto con &lt;code>setup.sh&lt;/code> para instalar temas, dotfiles y CLI personales.&lt;/p>
&lt;h2 id="-ejemplo-de-flujo-automatizado-para-onboarding">🛠️ Ejemplo de flujo automatizado para onboarding&lt;/h2>
&lt;ol>
&lt;li>Crear distro base con &lt;code>wsl --import&lt;/code>&lt;/li>
&lt;li>Configurar &lt;code>wsl.conf&lt;/code> y archivos de &lt;code>cloud-init&lt;/code>&lt;/li>
&lt;li>Ejecutar provisioning&lt;/li>
&lt;li>Compartir imagen exportada (&lt;code>.tar&lt;/code>) con otros desarrolladores&lt;/li>
&lt;/ol></description></item><item><title>Introducción avanzada a WSL2</title><link>https://cmas.dev/posts/2024-04-05-wsl2-advanced-intro/</link><pubDate>Fri, 05 Apr 2024 00:00:00 -0400</pubDate><guid>https://cmas.dev/posts/2024-04-05-wsl2-advanced-intro/</guid><description>&lt;p>Desde su lanzamiento, WSL2 (Windows Subsystem for Linux 2) ha transformado el panorama del desarrollo en Windows, ofreciendo una integración casi nativa con Linux sin necesidad de usar máquinas virtuales tradicionales. A diferencia de WSL1, que traducía llamadas del sistema de Linux a Windows, WSL2 ejecuta un kernel Linux completo dentro de una VM optimizada y ligera. Esta diferencia técnica lo convierte en una herramienta poderosa para desarrolladores modernos, DevOps, científicos de datos y más.&lt;/p>
&lt;h2 id="-diferencias-clave-entre-wsl1-y-wsl2">🔍 Diferencias clave entre WSL1 y WSL2&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Característica&lt;/th>
&lt;th>WSL1&lt;/th>
&lt;th>WSL2&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Kernel Linux&lt;/td>
&lt;td>No (traducción de llamadas)&lt;/td>
&lt;td>Sí (kernel completo real)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Compatibilidad syscall&lt;/td>
&lt;td>Limitada&lt;/td>
&lt;td>Total&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Performance en filesystem&lt;/td>
&lt;td>Más rápido en &lt;code>/mnt/c/&lt;/code>&lt;/td>
&lt;td>Más rápido en &lt;code>/home/&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Soporte para Docker&lt;/td>
&lt;td>Parcial&lt;/td>
&lt;td>Completo con Docker Desktop y systemd&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Uso de memoria&lt;/td>
&lt;td>Bajo&lt;/td>
&lt;td>Mayor (usa VM)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="-arquitectura-de-wsl2">🧱 Arquitectura de WSL2&lt;/h2>
&lt;ul>
&lt;li>Utiliza una máquina virtual ligera basada en Hyper-V, completamente administrada por Windows.&lt;/li>
&lt;li>El kernel Linux es compilado y mantenido por Microsoft, lo que garantiza compatibilidad y actualizaciones.&lt;/li>
&lt;li>Usa un sistema de archivos virtual (ext4) por cada distro, que puede residir en un archivo &lt;code>.vhdx&lt;/code>.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl"># Ver distros instaladas con su estado
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">wsl --list --verbose
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="-flujos-de-trabajo-avanzados">⚙️ Flujos de trabajo avanzados&lt;/h2>
&lt;h3 id="-casos-de-uso-reales">🧪 Casos de uso reales&lt;/h3>
&lt;ol>
&lt;li>&lt;strong>DevOps híbrido&lt;/strong>: Ejecutar herramientas de infraestructura (Terraform, Ansible) nativamente en Linux.&lt;/li>
&lt;li>&lt;strong>Desarrollo Backend&lt;/strong>: Node, Rust, Python o Go sobre distros Linux con acceso directo a servicios como PostgreSQL o Redis.&lt;/li>
&lt;li>&lt;strong>Data Science &amp;amp; AI&lt;/strong>: Compatibilidad con CUDA para entrenamiento de modelos con GPU.&lt;/li>
&lt;li>&lt;strong>CI/CD local&lt;/strong>: Crear pipelines reproducibles desde scripts Bash antes de subirlos a GitHub Actions o Azure Pipelines.&lt;/li>
&lt;/ol>
&lt;h2 id="-consideraciones-y-tips">⚠️ Consideraciones y tips&lt;/h2>
&lt;ul>
&lt;li>Evita trabajar en archivos dentro de &lt;code>/mnt/c/&lt;/code> si quieres máxima performance.&lt;/li>
&lt;li>Usa &lt;code>.wslconfig&lt;/code> para limitar recursos (CPU, memoria, swap) usados por la VM.&lt;/li>
&lt;li>Configura &lt;code>~/.wslconfig&lt;/code> para tunear el entorno global.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">[wsl2]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">memory=4GB
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">processors=2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">swap=2GB
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Django sobre WSL</title><link>https://cmas.dev/posts/2022-12-21-django-on-wsl/</link><pubDate>Wed, 21 Dec 2022 19:39:00 -0400</pubDate><guid>https://cmas.dev/posts/2022-12-21-django-on-wsl/</guid><description>&lt;p>En este corto artículo veremos cómo desarrollar sobre &lt;strong>WSL (Windows Subsystem for Linux)&lt;/strong> con &lt;strong>Python&lt;/strong> y &lt;strong>Django&lt;/strong>. Ya hemos visto que lo podemos hacer con &lt;a href="https://cmas.dev/posts/2022-06-29-java-with-wsl-part-2/">Java&lt;/a>&lt;/p>
&lt;p>&lt;em>&lt;strong>Windows 11 Insider Preview Build 25267&lt;/strong>&lt;/em>&lt;/p>
&lt;p>&lt;strong>WSL&lt;/strong> nos ofrece demasiadas ventajas a la hora de desarrollar software sobre el sistema operativo Linux, en este caso &lt;strong>Ubuntu&lt;/strong>. Hoy en día Python es un lenguaje demasiado difundido y muy utilizado en varios ámbitos, con sus ventajas y desventajas como todas las plataformas existentes. A eso le sumaron un Framework muy potente y completo &amp;ldquo;&lt;strong>Django&lt;/strong>&amp;rdquo;.&lt;/p>
&lt;p>Aquí veremos como instalar y ejecutar una aplicación web &lt;strong>Django&lt;/strong> utilizando &lt;strong>Visual Studio Code&lt;/strong>.&lt;/p>
&lt;h2 id="instalar-django-en-wslubuntu">Instalar Django en &lt;strong>WSL:Ubuntu&lt;/strong>&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>Abrimos &lt;strong>Windows Terminal&lt;/strong> con el perfil &lt;strong>Ubuntu&lt;/strong>:
&lt;img src="https://cmas.dev/img/posts/2022/12/21/1.png" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Procedemos a instalar &lt;strong>Django&lt;/strong> con el siguiente comando:&lt;/p>
&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">sudo apt install python3-django
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>
&lt;p>Seguimos las instrucciones en pantalla y listo.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Verificamos la instalación con el siguiente comando:&lt;/p>
&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">django-admin --version
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://cmas.dev/img/posts/2022/12/21/2.png" alt="">&lt;/p>
&lt;h2 id="crear-proyecto-django-y-empezar-a-trabajar">Crear proyecto Django y empezar a trabajar&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>Ir a la carpeta donde debe estar nuestro proyecto:
&lt;img src="https://cmas.dev/img/posts/2022/12/21/3.png" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Crear un ambiente virtual de &lt;strong>Python&lt;/strong>:&lt;/p>
&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">$ python3 -m venv pythonTest
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>Activar el ambiente virtual:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">$ source pythonTest/bin/activate
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="4">
&lt;li>Instalar &lt;strong>Django&lt;/strong> en el ambiente virtual:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(pythonTest) $ pip install django
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="5">
&lt;li>Se crea el proyecto en la carpeta actual:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(pythonTest) $ django-admin startproject testproject .
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="6">
&lt;li>Migramos la base de datos inicial:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(pythonTest) $ python manage.py migrate
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="7">
&lt;li>Se crea la administracion de la Web:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(pythonTest) $ python manage.py createsuperuser
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="8">
&lt;li>
&lt;p>Completamos los datos y listo:
&lt;img src="https://cmas.dev/img/posts/2022/12/21/4.png" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Abrimos la carpeta donde alojamos el proyecto y empezamos a desarrollar:
&lt;img src="https://cmas.dev/img/posts/2022/12/21/5.png" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Activamos el ambiernte virtual de Python y ejecutamos el servidor de Django:
&lt;img src="https://cmas.dev/img/posts/2022/12/21/6.png" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Veremos la página principal de Django:
&lt;img src="https://cmas.dev/img/posts/2022/12/21/7.png" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Si accedemos a la URL con el contexto &lt;em>/admin&lt;/em> veremos lo siguiente:
&lt;img src="https://cmas.dev/img/posts/2022/12/21/8.png" alt="">&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://cmas.dev/img/posts/2022/12/21/9.png" alt="">&lt;/p>
&lt;p>Listo para desarrollar aplicaciones web con &lt;strong>Django&lt;/strong> y &lt;strong>Python&lt;/strong> sobre &lt;strong>Visual Studio Code&lt;/strong> y &lt;strong>WSL&lt;/strong>.&lt;/p>
&lt;p>¡Espero resulte útil!&lt;/p></description></item><item><title>Desarrollo con Python sobre WSL</title><link>https://cmas.dev/posts/2022-12-14-developing-python-on-wsl/</link><pubDate>Wed, 14 Dec 2022 21:12:00 -0400</pubDate><guid>https://cmas.dev/posts/2022-12-14-developing-python-on-wsl/</guid><description>&lt;p>En este corto artículo veremos cómo desarrollar sobre &lt;strong>WSL (Windows Subsystem for Linux)&lt;/strong> con &lt;strong>Python&lt;/strong>. Ya hemos visto que lo podemos hacer con &lt;a href="https://cmas.dev/posts/2022-06-29-java-with-wsl-part-2/">Java&lt;/a>&lt;/p>
&lt;p>&lt;em>&lt;strong>Windows 11 Insider Preview Build 25267&lt;/strong>&lt;/em>&lt;/p>
&lt;p>&lt;strong>WSL&lt;/strong> nos ofrece demasiadas ventajas a la hora de desarrollar software sobre el sistema operativo Linux, en este caso &lt;strong>Ubuntu&lt;/strong>. Hoy en día Python es un lenguaje demasiado difundido y muy utilizado en varios ámbitos, con sus ventajas y desventajas como todas las plataformas existentes.&lt;/p>
&lt;p>Aquí veremos como instalar y ejecutar un pequeño código utilizando &lt;strong>Visual Studio Code&lt;/strong>.&lt;/p>
&lt;h2 id="python-en-wsl">Python en WSL&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>Abrimos Visual Studio Code (pero en WSL):
&lt;img src="https://cmas.dev/img/posts/2022/12/14/1.png" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>En extensiones, buscamos &amp;ldquo;python&amp;rdquo; y lo instalamos (el fabricante debe ser Microsoft):
&lt;img src="https://cmas.dev/img/posts/2022/12/14/2.png" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Luego de la instalación, procedemos a crear un nuevo archivo:
&lt;img src="https://cmas.dev/img/posts/2022/12/14/3.png" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Seleccionamos el archivo de tipo Python, colocamos en el lugar de preferencia (dentro del WSL):
&lt;img src="https://cmas.dev/img/posts/2022/12/14/4.png" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Crear un archivo nuevo &lt;strong>pythonTest.py&lt;/strong> (en mi caso) y escribir el siguiente código.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">print(&amp;#34;Hello, World from VS Code and WSL&amp;#34;)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="6">
&lt;li>
&lt;p>Casi hacemos &lt;em>F5&lt;/em> pero notamos que falta algo:
&lt;img src="https://cmas.dev/img/posts/2022/12/14/5.png" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Seleccionamos el Intérprete recomendado:
&lt;img src="https://cmas.dev/img/posts/2022/12/14/6.png" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Seleccionamos la configuración del depurador (porque es un archivo suelto):
&lt;img src="https://cmas.dev/img/posts/2022/12/14/7.png" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Ejecutamos nuestro archivo &lt;strong>.py&lt;/strong> y listo:
&lt;img src="https://cmas.dev/img/posts/2022/12/14/8.png" alt="">&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>¡Espero resulte útil!&lt;/p></description></item><item><title>Visual Studio Code Server WSL</title><link>https://cmas.dev/posts/2022-10-19-visual-studio-code-server-wsl/</link><pubDate>Wed, 19 Oct 2022 22:35:00 -0400</pubDate><guid>https://cmas.dev/posts/2022-10-19-visual-studio-code-server-wsl/</guid><description>&lt;p>En este artículo corto, pero preciso, mostraré cómo utilizar &lt;strong>Visual Studio Code&lt;/strong> como servidor de &lt;strong>WSL&lt;/strong> para facilitarnos la vida en ciertas pruebas que tenemos como desarrolladores.&lt;/p>
&lt;p>&lt;em>&lt;strong>Windows 11 Insider Preview Build 25227&lt;/strong>&lt;/em>&lt;/p>
&lt;p>&lt;strong>Visual Studio Code Server&lt;/strong> es un servicio que se puede ejecutar en una máquina de desarrollo remota, como la PC de escritorio o una máquina virtual (VM). Permite conectar de forma segura a esa máquina remota desde cualquier lugar a través de un cliente local de &lt;strong>VS Code&lt;/strong>, sin la necesidad de &lt;strong>SSH&lt;/strong>. También se puede acceder al servidor a través del navegador usando &lt;strong>VS Code&lt;/strong> para la Web (también conocido como &lt;strong>vscode.dev&lt;/strong>).&lt;/p>
&lt;p>La arquitectura del servicio lo expone Microsoft en su web:
&lt;img src="https://code.visualstudio.com/assets/docs/remote/vscode-server/server-arch-latest.png" alt="">&lt;/p>
&lt;h2 id="configurar-acceso">Configurar acceso&lt;/h2>
&lt;p>Para que esto funcione se debe enlazar con &lt;strong>GitHub&lt;/strong> para que nos cree el &lt;strong>CodeSpace&lt;/strong> necesario.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Se accede al entorno de &lt;strong>WSL:Ubuntu&lt;/strong> para hacer las gestiones:
&lt;img src="https://cmas.dev/img/posts/2022/10/19/1.png" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Una vez allí se verifica que el Visual Studio Code corresponda a &lt;strong>Ubuntu&lt;/strong>:&lt;br>
&lt;img src="https://cmas.dev/img/posts/2022/10/19/2.png" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Accedemos al menú contextual de &amp;ldquo;Turn on Remote Tunnel Access&amp;hellip;&amp;rdquo;:
&lt;img src="https://cmas.dev/img/posts/2022/10/19/3.png" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Seguimos las instrucciones en pantalla para Iniciar sesión en &lt;strong>GitHub&lt;/strong>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Habilitar el Tunnel Remoto:
&lt;img src="https://cmas.dev/img/posts/2022/10/19/4.png" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Copiar el enlace que se muestra en la ventana emergente:
&lt;img src="https://cmas.dev/img/posts/2022/10/19/5.png" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Acceder al navegador de prefrencia y veremos nuestro Visual Studio remoto (que mantiene el enlace con nuestro Visual Studio WSL local):
&lt;img src="https://cmas.dev/img/posts/2022/10/19/6.png" alt="">&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>¡Espero resulte útil!&lt;/p></description></item><item><title>Java con WSL parte 2</title><link>https://cmas.dev/posts/2022-06-29-java-with-wsl-part-2/</link><pubDate>Wed, 29 Jun 2022 20:47:00 -0400</pubDate><guid>https://cmas.dev/posts/2022-06-29-java-with-wsl-part-2/</guid><description>&lt;p>En este artículo mostraré cómo desarrollar una pequeña aplicación web en &lt;strong>Java&lt;/strong> corriendo sobre &lt;strong>WSL (Windows Subsystem for Linux)&lt;/strong>. En el &lt;a href="https://cmas.dev/posts/2022-06-22-java-with-wsl-part-1/">artículo anterior&lt;/a> hemos visto como preparar &lt;strong>Visual Studio Code&lt;/strong> para &lt;strong>Java&lt;/strong> sobre &lt;strong>WSL (Windows Subsystem for Linux)&lt;/strong>.&lt;/p>
&lt;p>&lt;em>&lt;strong>Windows 11 Insider Preview Build 25151&lt;/strong>&lt;/em>&lt;/p>
&lt;p>Vamos a ponernos un poco creativos ahora y veremos cómo crear una aplicación web con Java. PAra ellos debemos utilizar el proyecto &lt;a href="https://maven.apache.org/">&lt;strong>Apache Maven&lt;/strong>&lt;/a> y lo utilizaremos desde &lt;strong>Visual Studio Code&lt;/strong> sobre la plataforma &lt;strong>WSL&lt;/strong>.&lt;/p>
&lt;h2 id="instalar-apache-maven">Instalar Apache Maven&lt;/h2>
&lt;ol>
&lt;li>Descargar el instalador:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">wget https://dlcdn.apache.org/maven/maven-3/3.9.0/binaries/apache-maven-3.9.0-bin.zip -P /tmp
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>Extraer los archivos a &lt;strong>/opt/gradle&lt;/strong>:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">sudo unzip -d /opt/apache-maven /tmp/apache-maven-3.9.0-bin.zip
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>Configurar la variable de entorno creando &lt;strong>maven.sh&lt;/strong>&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">sudo vi /etc/profile.d/maven.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="4">
&lt;li>Agregamos lo siguiente a ese archivo:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># /etc/profile.d/maven.sh&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">export&lt;/span> &lt;span class="n">MAVEN_HOME&lt;/span>&lt;span class="o">=/&lt;/span>&lt;span class="n">opt&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">apache&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">maven&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">apache&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">maven&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mf">3.9&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="o">/&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">export&lt;/span> &lt;span class="n">PATH&lt;/span>&lt;span class="o">=$&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">MAVEN_HOME&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">bin&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="o">$&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">PATH&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="5">
&lt;li>Convertir el archivo en ejecutable:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">sudo chmod +x /etc/profile.d/maven.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="6">
&lt;li>Cargamos la variable de entorno&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">source /etc/profile.d/maven.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="7">
&lt;li>Verificamos que todo esté bien:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">mvn -v
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://cmas.dev/img/posts/2022/06/29/1.png" alt="">&lt;/p>
&lt;h2 id="crear-un-proyecto-java-spring-boot">Crear un proyecto Java Spring Boot&lt;/h2>
&lt;p>No tenemos una plantilla como tal en Visual Studio Code, no es un IDE potente como otros que existen en el mercado para Java.&lt;/p>
&lt;p>Entonces procedemos con los siguientes pasos:&lt;/p>
&lt;ol>
&lt;li>Clonamos el repositorio de GitHub &lt;a href="https://github.com/spring-guides/gs-spring-boot.git">https://github.com/spring-guides/gs-spring-boot.git&lt;/a>
&lt;img src="https://cmas.dev/img/posts/2022/06/29/2.png" alt="">&lt;/li>
&lt;li>Ejecutamos la applicación y veremos el texto predeterminado:
&lt;img src="https://cmas.dev/img/posts/2022/06/29/3.png" alt="">&lt;/li>
&lt;/ol>
&lt;p>Con todo esto tenemos una aplicación Web desarrollada en &lt;strong>Java&lt;/strong> con el servidor corriendo en &lt;strong>Ubuntu&lt;/strong> gracias a &lt;strong>WSL&lt;/strong> sin salis de nuestro sistema operativo &lt;strong>Windows&lt;/strong>.&lt;/p>
&lt;p>¡Espero resulte útil!&lt;/p></description></item><item><title>Java con WSL parte 1</title><link>https://cmas.dev/posts/2022-06-22-java-with-wsl-part-1/</link><pubDate>Wed, 22 Jun 2022 18:19:00 -0400</pubDate><guid>https://cmas.dev/posts/2022-06-22-java-with-wsl-part-1/</guid><description>&lt;p>En este artículo mostraré cómo instalar y preparar el entorno para el desarrollo de &lt;strong>Java&lt;/strong> sobre &lt;strong>Windows Subsystem for Linux (WSL)&lt;/strong>.&lt;/p>
&lt;p>&lt;em>&lt;strong>Windows 11 Insider Preview Build 25145&lt;/strong>&lt;/em>&lt;/p>
&lt;p>Personalmente no soy desarrollador Java, pero desde que lo estudié (obligado) en la Universidad siempre le seguí el rastro. El lenguaje, la plataforma en general, para mi gusto es lento y a veces frustrante. Pero esa es una opinión muy particular.&lt;/p>
&lt;p>El foco aquí es ver como instalar todo el paquete y sacar una pequeña web. Según la encuesta anual de StackOverflow Java se posiciona entre uno de los primeros lenguajes. &lt;a href="https://survey.stackoverflow.co/2022/#section-most-popular-technologies-programming-scripting-and-markup-languages">Aquí&lt;/a> se encuentra la encuesta para quien esté interesado.&lt;/p>
&lt;h2 id="instalar-java-desde-visual-studio-code-en-wsl">Instalar Java desde Visual Studio Code en WSL&lt;/h2>
&lt;p>Existe el proceso manual (para las personas que quieren isntalarlo asegurando todos los pasos). Cómo sólo estoy investigando (y publicando la investigación) iremos por el camino más corto.&lt;/p>
&lt;p>Para ello, haremos los siguientes pasos:&lt;/p>
&lt;ol>
&lt;li>En &lt;strong>WSL:Ubuntu&lt;/strong>, ingresaremos el comando:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">code
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://cmas.dev/img/posts/2022/06/22/1.png" alt="">&lt;br>
2. En Visual Studio Code (WSL) procedemos a instalar los objetos necesarios (esto debido a que toda la instalación estará en Ubuntu):
&lt;img src="https://cmas.dev/img/posts/2022/06/22/2.png" alt="">&lt;br>
3. Veamos que versión de Java tenemos&amp;hellip;
&lt;img src="https://cmas.dev/img/posts/2022/06/22/3.png" alt="">&lt;br>
4. Debemos instalar el &lt;strong>JVM (Java Virtual Machine)&lt;/strong> para que funcione:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">sudo apt install default-jdk
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://cmas.dev/img/posts/2022/06/22/4.png" alt="">&lt;br>
5. Establecemos el &lt;strong>Java Home&lt;/strong>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span class="line">&lt;span class="cl">&lt;span class="n">sudo&lt;/span> &lt;span class="n">vi&lt;/span> &lt;span class="o">~/.&lt;/span>&lt;span class="n">bashrc&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">export&lt;/span> &lt;span class="n">JAVA_HOME&lt;/span>&lt;span class="o">=/&lt;/span>&lt;span class="n">usr&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">lib&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">jvm&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">java&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">11&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">openjdk&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">amd64&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="6">
&lt;li>Verificamos la versión de &lt;strong>Java&lt;/strong>
&lt;img src="https://cmas.dev/img/posts/2022/06/22/5.png" alt="">&lt;/li>
&lt;/ol>
&lt;h2 id="instalar-gradle-para-los-proyectos-java">Instalar Gradle para los proyectos Java&lt;/h2>
&lt;ol>
&lt;li>Descargar Gradle a una carpeta temporal:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">wget https://services.gradle.org/distributions/gradle-7.3.3-bin.zip -P /tmp
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>Extraer los archivos a &lt;strong>/opt/gradle&lt;/strong>:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">sudo apt install unzip
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo unzip -d /opt/gradle /tmp/gradle-*.zip
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>Verificar los archivos:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ls /opt/gradle/gradle-7.3.3/
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="4">
&lt;li>Configurar la variable de entorno creando &lt;strong>gradle.sh&lt;/strong>&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">sudo vi /etc/profile.d/gradle.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="5">
&lt;li>Agregamos lo siguiente a ese archivo:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># /etc/profile.d/gradle.sh&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">export&lt;/span> &lt;span class="n">GRADLE_HOME&lt;/span>&lt;span class="o">=/&lt;/span>&lt;span class="n">opt&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">gradle&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">gradle&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mf">7.3&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="mi">3&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">export&lt;/span> &lt;span class="n">PATH&lt;/span>&lt;span class="o">=$&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">GRADLE_HOME&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">bin&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="o">$&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">PATH&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="6">
&lt;li>Convertir el archivo en ejecutable:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">sudo chmod +x /etc/profile.d/gradle.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="7">
&lt;li>Cargamos la variable de entorno&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">source /etc/profile.d/gradle.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="8">
&lt;li>Verificamos que todo esté bien:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">gradle -v
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://cmas.dev/img/posts/2022/06/22/6.png" alt="">&lt;br>
9. Instalar la extensión &lt;strong>Gradle for Java&lt;/strong>
&lt;img src="https://cmas.dev/img/posts/2022/06/22/7.png" alt="">&lt;/p>
&lt;h2 id="crear-un-proyecto-java">Crear un proyecto Java&lt;/h2>
&lt;ol>
&lt;li>Crear el proyecto Java:
&lt;img src="https://cmas.dev/img/posts/2022/06/22/8.png" alt="">&lt;/li>
&lt;li>Marcamos la opción de &amp;ldquo;No build tools&amp;rdquo;:
&lt;img src="https://cmas.dev/img/posts/2022/06/22/9.png" alt="">&lt;/li>
&lt;li>Seguimos las instrucciones en pantalla para la creación del proyecto.&lt;/li>
&lt;li>Modificamos el archivo &lt;strong>App.java&lt;/strong>:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class App {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static void main(String[] args) throws Exception {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> System.out.println(&amp;#34;Hello, World from cmasdev!&amp;#34;);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="5">
&lt;li>Ejecutamos la aplicación con &lt;em>F5&lt;/em>:
&lt;img src="https://cmas.dev/img/posts/2022/06/22/10.png" alt="">&lt;/li>
&lt;/ol>
&lt;p>¡Espero resulte útil!&lt;/p></description></item><item><title>ASP.NET Core en Ubuntu</title><link>https://cmas.dev/posts/2022-06-15-aspnet-core-on-ubuntu/</link><pubDate>Wed, 15 Jun 2022 12:08:00 -0400</pubDate><guid>https://cmas.dev/posts/2022-06-15-aspnet-core-on-ubuntu/</guid><description>&lt;p>En este artículo mostraré cómo ejecutar una aplicación &lt;strong>ASP.NET Core&lt;/strong> sobre &lt;strong>Windows Subsystem for Linux&lt;/strong>, es decir, alojar un servidor web en Ubuntu para ejecutar nuestra aplicación web.&lt;/p>
&lt;p>&lt;em>&lt;strong>Windows 11 Insider Preview Build 25140&lt;/strong>&lt;/em>&lt;/p>
&lt;p>Se habla mucho respecto a que .NET Core puede ejecutar aplicaciones nativamente en Linux (Ubuntu, en este caso) y es hora de hacer la prueba. En este caso, alojaremos la aplicación en un &amp;ldquo;servidor&amp;rdquo; Ubuntu para verificar su funcionamiento.&lt;/p>
&lt;h2 id="preparar-el-proyecto">Preparar el proyecto&lt;/h2>
&lt;p>Primeramente, debemos crear el poryecto &lt;strong>ASP.NET Core&lt;/strong>:&lt;/p>
&lt;ol>
&lt;li>Creamos el proyecto en Visual Studio 2022:
&lt;img src="https://cmas.dev/img/posts/2022/06/15/1.png" alt="">&lt;/li>
&lt;li>Colocamos un nombre descriptivo al proyecto nuevo:
&lt;img src="https://cmas.dev/img/posts/2022/06/15/2.png" alt="">&lt;/li>
&lt;li>Seleccionamos el .NET Core que deseamos utilizar:
&lt;img src="https://cmas.dev/img/posts/2022/06/15/3.png" alt="">&lt;/li>
&lt;li>Verificamos las opciones habilitadas para la ejecución (nos interesa &lt;strong>WSL&lt;/strong>):
&lt;img src="https://cmas.dev/img/posts/2022/06/15/4.png" alt="">&lt;/li>
&lt;/ol>
&lt;h2 id="ejecución-para-wsl">Ejecución para WSL&lt;/h2>
&lt;p>Empezamos a realizar las tareas relacionadas con la ejecución&lt;/p>
&lt;ol>
&lt;li>Hacemos clic en el botón de ejecución o presionamos la tecla &lt;em>F5&lt;/em>, saldrá un mensaje de error como este (si es que no tenemos instalado el dotnet en WSL):
&lt;img src="https://cmas.dev/img/posts/2022/06/15/5.png" alt="">&lt;/li>
&lt;li>SEguimos los pasos en la consola de WSL (para que se instale el motor de ejecución) y en Visual Studio aceptamos el mensaje:
&lt;img src="https://cmas.dev/img/posts/2022/06/15/6.png" alt="">&lt;/li>
&lt;li>Volvemos a ejecutar la aplicación (en este punto funciona):
&lt;img src="https://cmas.dev/img/posts/2022/06/15/7.png" alt="">&lt;/li>
&lt;li>Debemos agregar un poco de código para identificar en qué plataforma estamos (en la página index.cshtml agregamos la siguiente línea de código):&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">&amp;lt;h2&amp;gt;@Environment.OsVersion&amp;lt;/h2&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="5">
&lt;li>Ejecutamos de nuevo la aplicación, pero seleccionamos la opción que tiene el nombre de nuestro proyecto, para poder usar el Web Server de Windows:
&lt;img src="https://cmas.dev/img/posts/2022/06/15/8.png" alt="">&lt;/li>
&lt;li>Cambiamos la configuración a &lt;strong>WSL&lt;/strong> nuevamente y ejecutamos para ver el cambio:
&lt;img src="https://cmas.dev/img/posts/2022/06/15/9.png" alt="">&lt;/li>
&lt;/ol>
&lt;p>De esta manera hemos montado el servidor web directamente en &lt;strong>Ubuntu&lt;/strong> con &lt;strong>WSL&lt;/strong>.&lt;/p>
&lt;p>¡Espero resulte útil!&lt;/p></description></item><item><title>Desarrollo de aplicaciones NodeJs en WSL</title><link>https://cmas.dev/posts/2022-06-08-app-nodejs-in-wsl/</link><pubDate>Wed, 08 Jun 2022 18:07:00 -0400</pubDate><guid>https://cmas.dev/posts/2022-06-08-app-nodejs-in-wsl/</guid><description>&lt;p>En este artículo mostraré como instalar &lt;strong>Node.js&lt;/strong> en &lt;strong>WSL&lt;/strong>. También, veremos como escribir código, compilar y ejecutarlo en &lt;strong>WSL&lt;/strong> desde &lt;strong>Visual Studio Code&lt;/strong>.&lt;/p>
&lt;p>&lt;em>&lt;strong>Windows 11 Insider Preview Build 25131&lt;/strong>&lt;/em>&lt;/p>
&lt;p>En Windows 11, especificamente gracias a &lt;strong>WSL - Windows Subssytem for Linux&lt;/strong> podemos instalar y ejecutar aplicaciones desarrolladas con &lt;strong>Node.js&lt;/strong> de manera bastante sencilla y rápida.&lt;/p>
&lt;h2 id="instalar-nodejs-en-wsl">Instalar Node.js en WSL&lt;/h2>
&lt;p>Preparamos WSL para la instalación de Node.js&lt;/p>
&lt;ol>
&lt;li>Verificamos las versiones de Node.js y NVM que tenemos instaladas (se supone que no las tenemos):
&lt;img src="https://cmas.dev/img/posts/2022/06/08/1.png" alt="">&lt;/li>
&lt;li>Procedemos a instalar NVM (Node Version Manager):&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>Ahora, instalamos la última versión de Node.js:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">nvm install node
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="4">
&lt;li>Verificamos las versiones y listo:
&lt;img src="https://cmas.dev/img/posts/2022/06/08/2.png" alt="">&lt;/li>
&lt;/ol>
&lt;h2 id="aplicacion-en-visual-studio-code">Aplicacion en Visual Studio Code&lt;/h2>
&lt;p>Dentro del Visual Studio Code creamos la aplicación y procedemos a ejecutarla normalmente.&lt;/p>
&lt;ol>
&lt;li>Creamos un archivo &lt;strong>app.js&lt;/strong>&lt;/li>
&lt;li>Escribimos las siguientes líneas de código:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span class="line">&lt;span class="cl">&lt;span class="k">var&lt;/span> &lt;span class="n">http&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">require&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;http&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">http&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">createServer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">function&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">req&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">res&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">res&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">writeHead&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">200&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="s1">&amp;#39;Content-Type&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s1">&amp;#39;text/plain&amp;#39;&lt;/span>&lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">res&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">end&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;Hola desde cmas.dev!&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">})&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">listen&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">8080&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>Presionamos la tecla &lt;em>F5&lt;/em> y seleccionamos la opción &lt;strong>Node.js&lt;/strong>:
&lt;img src="https://cmas.dev/img/posts/2022/06/08/4.png" alt="">&lt;/li>
&lt;li>Veremos los controles de depuración y en la consola veremos que ha creado la aplicación:
&lt;img src="https://cmas.dev/img/posts/2022/06/08/5.png" alt="">&lt;/li>
&lt;li>En el navegador de preferencia, colocamos la URL definida en el código y vermeos nuestro pequeña applicación:
&lt;img src="https://cmas.dev/img/posts/2022/06/08/6.png" alt="">&lt;/li>
&lt;/ol>
&lt;h2 id="aplicacion-en-visual-studio-code-con-wsl">Aplicacion en Visual Studio Code con WSL&lt;/h2>
&lt;p>Dentro del Visual Studio Code creamos la aplicación y procedemos a ejecutarla en WSL.&lt;/p>
&lt;ol>
&lt;li>Descargar la extensión para desarrollo remoto &lt;a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-wsl">aquí&lt;/a>&lt;/li>
&lt;li>Abrimos una nueva ventana de Visual Studio Code y hacemos clicn en el icono de acceso remoto:
&lt;img src="https://cmas.dev/img/posts/2022/06/08/7.png" alt="">&lt;/li>
&lt;li>Seleccionamos la opción de distro para WSL:
&lt;img src="https://cmas.dev/img/posts/2022/06/08/8.png" alt="">&lt;/li>
&lt;li>Marcamos la opción Ubuntu:
&lt;img src="https://cmas.dev/img/posts/2022/06/08/9.png" alt="">&lt;/li>
&lt;li>Abrimos la carpeta donde almacenaremos el proyecto (en Ubuntu):
&lt;img src="https://cmas.dev/img/posts/2022/06/08/10.png" alt="">&lt;/li>
&lt;li>Escribimos las siguientes líneas de código (con algunas diferencias del código anterior):&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span class="line">&lt;span class="cl">&lt;span class="k">var&lt;/span> &lt;span class="n">http&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">require&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;http&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">http&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">createServer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">function&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">req&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">res&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">res&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">writeHead&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">200&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="s1">&amp;#39;Content-Type&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s1">&amp;#39;text/plain&amp;#39;&lt;/span>&lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">res&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">end&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;¡Hola desde cmas.dev y WSL!&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">})&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">listen&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">8081&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="7">
&lt;li>Ejecutamos la aplicación desde la Terminal de &lt;strong>Ubuntu&lt;/strong>:
&lt;img src="https://cmas.dev/img/posts/2022/06/08/12.png" alt="">&lt;/li>
&lt;li>Abrimos el navegador y colocamos la dirección que especificamos en el código:
&lt;img src="https://cmas.dev/img/posts/2022/06/08/13.png" alt="">&lt;/li>
&lt;/ol>
&lt;p>De esta manera hemos realizado una aplicación NodeJs en &lt;strong>Windows&lt;/strong> directamente así como en &lt;strong>WSL&lt;/strong>. Ambas opciones son válidas, nada más depende de la elección del desarrollador.&lt;/p>
&lt;p>¡Espero resulte útil!&lt;/p></description></item><item><title>WSL: Ejecutar aplicaciones con GUI Linux</title><link>https://cmas.dev/posts/2022-06-01-wsl-run-apps-gui-ubuntu/</link><pubDate>Wed, 01 Jun 2022 18:32:00 -0400</pubDate><guid>https://cmas.dev/posts/2022-06-01-wsl-run-apps-gui-ubuntu/</guid><description>&lt;p>En este artículo mostraré cómo utilizar aplicaciones Linux (con interfaz de usuario) gracias a &lt;strong>Windows Subsystem for Linux&lt;/strong> .&lt;/p>
&lt;p>&lt;em>&lt;strong>Windows 11 Insider Preview Build 22621&lt;/strong>&lt;/em>&lt;/p>
&lt;p>Es cierto que &lt;strong>Windows&lt;/strong> posee muchas y muy buenas aplicaciones gráficas (de hecho está basado en eso), pero Ubuntu también tiene aplicaciones muy buenas y con performance mejorada.&lt;/p>
&lt;h2 id="instalar-vlc">Instalar VLC&lt;/h2>
&lt;p>En este caso instalaremos el reproductor multimedia VLC:&lt;/p>
&lt;ol>
&lt;li>Nos dirigimos a Ubuntu &lt;strong>Windows Subsystem for Linux&lt;/strong>
&lt;img src="https://cmas.dev/img/posts/2022/06/01/1.png" alt="">&lt;/li>
&lt;li>Colocamos el comando que instala la aplicación con &lt;strong>apt&lt;/strong>:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">sudo apt install vlc -y
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>Procede a instalar y nos arroja el resultado:
&lt;img src="https://cmas.dev/img/posts/2022/06/01/2.png" alt="">&lt;/li>
&lt;li>Colocamos el comando que ejecuta la aplicación y&amp;hellip;&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">vlc
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="5">
&lt;li>Veremos la aplicación ejecutada:
&lt;img src="https://cmas.dev/img/posts/2022/06/01/3.png" alt="">&lt;/li>
&lt;li>Si buscamos la App desde el Menú Inicio de &lt;strong>Windows&lt;/strong> la encontraremos:
&lt;img src="https://cmas.dev/img/posts/2022/06/01/4.png" alt="">&lt;/li>
&lt;li>La aplicación se ejecuta de manera nativa en &lt;strong>Windows&lt;/strong>:
&lt;img src="https://cmas.dev/img/posts/2022/06/01/5.png" alt="">&lt;/li>
&lt;/ol>
&lt;p>¡Espero resulte útil!&lt;/p></description></item><item><title>Git y WSL</title><link>https://cmas.dev/posts/2022-05-04-git-and-wsl/</link><pubDate>Wed, 04 May 2022 13:48:00 -0400</pubDate><guid>https://cmas.dev/posts/2022-05-04-git-and-wsl/</guid><description>&lt;p>En este artículo mostraré cómo instalar o actualizar git dentro de &lt;strong>Windows Subsystem for Linux&lt;/strong> de modo a poder clonar repositorio desde y hacia &lt;strong>GitHub&lt;/strong>. En un &lt;a href="https://cmas.dev/posts/2022-04-26-configuring-my-wsl-environment/">artículo anterior&lt;/a> hemos visto cómo habilitar la plataforma &lt;strong>Windows Subsystem for Linux&lt;/strong>.&lt;/p>
&lt;p>&lt;em>&lt;strong>Windows 11 Insider Preview Build 22610&lt;/strong>&lt;/em>&lt;/p>
&lt;p>Debemos seguir algunos pasos para poder isntalar/actualizar &lt;em>Git&lt;/em> dentro de &lt;strong>WSL&lt;/strong> en &lt;em>Windows 11&lt;/em>.&lt;/p>
&lt;h2 id="instalar-git-en-wsl">Instalar Git en WSL&lt;/h2>
&lt;p>Realmente, resulta muy complicado que &lt;strong>WSL&lt;/strong> no traiga instalado &lt;strong>Git&lt;/strong> (lo considera una herramienta indispensable para los desarrolladores), pero si es el caso debemos seguir estos pasos:&lt;/p>
&lt;ol>
&lt;li>Iniciar la aplicación &lt;strong>Windows Subsystem for Linux (Ubuntu)&lt;/strong>.&lt;/li>
&lt;li>Verificamos la versión de Git instalada:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">git --version
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>Asumimos que no tenemos instalado &lt;strong>Git&lt;/strong> (aunque es difícil), entonces procedemos a instalarlo con el comenado &lt;strong>apt-get&lt;/strong>:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">sudo apt install git
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="4">
&lt;li>Veremos la versión actual instalada(Ojo: no es lo mismo Git en Windows que Git en WSL, pueden ser versiones distintas):
&lt;img src="https://cmas.dev/img/posts/2022/05/04/1.png" alt="">&lt;/li>
&lt;/ol>
&lt;h2 id="actualizar-git-en-wsl">Actualizar Git en WSL&lt;/h2>
&lt;p>Debemos seguir algunos pasos sencillos para lograrlos. Estos serían:&lt;/p>
&lt;ol>
&lt;li>Verificamos la versión de Git instalada:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">git --version
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>Actualizamos Git utilizando el mismo comando de instalación:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">sudo apt install git
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>Luego de actualizar tendremos la última versión disponible&lt;/li>
&lt;/ol>
&lt;p>¡Espero resulte útil!&lt;/p></description></item><item><title>WSL sin internet</title><link>https://cmas.dev/posts/2022-04-27-wsl-no-internet/</link><pubDate>Wed, 27 Apr 2022 12:26:00 -0400</pubDate><guid>https://cmas.dev/posts/2022-04-27-wsl-no-internet/</guid><description>&lt;p>En este artículo mostraré cómo conectar a internet en &lt;strong>Windows Subsystem for Linux&lt;/strong> para cualquier distro (pero aquí siempre con Ubuntu) utilizando &lt;strong>Windows Terminal&lt;/strong>.&lt;/p>
&lt;p>&lt;em>&lt;strong>Windows 11 Insider Preview Build 22598&lt;/strong>&lt;/em>&lt;/p>
&lt;p>Debemos seguir algunos pasos sencillos para poder habilitar internet de manera permanente en nuestra distro preferida.&lt;/p>
&lt;h2 id="conexión-a-internet-en-windows-subsystem-for-linux">Conexión a internet en Windows Subsystem for Linux&lt;/h2>
&lt;p>Primero, hacemos ping a algún DNS (que tenga salida a internet):
&lt;img src="https://cmas.dev/img/posts/2022/04/27/wsl1.png" alt="">&lt;/p>
&lt;p>Entonces, debemos abrirl el archivo &lt;strong>resolv.conf&lt;/strong> que se encuentra en nuestro distro WSL:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">nano /etc/resolv.conf
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Abrirá el editor y procedemos a verificar el dato presente allí:
&lt;img src="https://cmas.dev/img/posts/2022/04/27/wsl3.png" alt="">&lt;/p>
&lt;p>Esa IP es privada. ¡Quítala de allí! y usemos el DNS de Google:
&lt;img src="https://cmas.dev/img/posts/2022/04/27/wsl4.png" alt="">&lt;/p>
&lt;p>Probemos nuestro comando &lt;strong>ping&lt;/strong> a ver que ocurre:
&lt;img src="https://cmas.dev/img/posts/2022/04/27/wsl5.png" alt="">&lt;/p>
&lt;h2 id="configuración-permanente-para-acceso-a-internet">Configuración permanente para acceso a Internet&lt;/h2>
&lt;p>Como paso de prueba podemos salir de Ubuntu (emular el apagado de equipo desde &lt;strong>Windows Terminal&lt;/strong>, no desde Ubuntu):
&lt;img src="https://cmas.dev/img/posts/2022/04/27/wsl6.png" alt="">&lt;/p>
&lt;p>Iniciamos Ubuntu nuevamente y probamos &lt;strong>ping&lt;/strong>:
&lt;img src="https://cmas.dev/img/posts/2022/04/27/wsl1.png" alt="">&lt;/p>
&lt;p>¡BOOM!&lt;/p>
&lt;p>Corregimos esto al estilo Ubuntu, con &lt;strong>Terminal&lt;/strong>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">sudo bash -c &amp;#39;echo -e &amp;#34;[network]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">generateResolvConf = false&amp;#34; &amp;gt; /etc/wsl.conf
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">echo -e &amp;#34;options timeout:1 attempts:1 rotate
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">nameserver 8.8.8.8
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">nameserver 8.8.4.4&amp;#34; &amp;gt; /etc/resolv.conf
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">chattr -f +i /etc/resolv.conf&amp;#39;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Con esto, logramos que todo funcione correctamente&amp;gt;
&lt;img src="https://cmas.dev/img/posts/2022/04/27/wsl5.png" alt="">&lt;/p>
&lt;p>¡Espero resulte útil!&lt;/p></description></item><item><title>Configurando mi ambiente WSL</title><link>https://cmas.dev/posts/2022-04-26-configuring-my-wsl-environment/</link><pubDate>Tue, 26 Apr 2022 20:41:00 -0400</pubDate><guid>https://cmas.dev/posts/2022-04-26-configuring-my-wsl-environment/</guid><description>&lt;p>En este artículo mostraré cómo configurar un ambiente de desarrollo WSL (Windows Subsystem Linux) dentro de Windows para el desarrollo de aplicaciones en múltiples plataformas (que en el futuro iré asociando a este artículo). Para este artículo ya tenemos disponible la nueva distro de Ubuntu 22.04 (recientemente lanzada).&lt;/p>
&lt;p>&lt;em>&lt;strong>Windows 11 Insider Preview Build 22598&lt;/strong>&lt;/em>&lt;/p>
&lt;p>Debemos seguir algunos pasos para poder habilitar el WSL (Windows Subsystem for Linux) en Windows 11. Es excelente esto para probar todo tipo de aplicaciones sin salir de Windows. Especialmente preparado para .NET Core :)&lt;/p>
&lt;h2 id="preparar-windows-subsystem-for-linux">Preparar Windows Subsystem for Linux&lt;/h2>
&lt;p>Para preparar la plataforma debemos seguir estos pasos:&lt;/p>
&lt;ol>
&lt;li>Nos dirigimos a &lt;strong>Panel de Control&lt;/strong> &amp;gt; &lt;strong>Programas&lt;/strong> &amp;gt; &lt;strong>Habilitar funcionalidades de Windows&lt;/strong>.&lt;/li>
&lt;li>Buscar la opción &lt;strong>Windows Subsystem for Linux&lt;/strong>, marcamos la opción y hacemos clic en &lt;strong>Aceptar&lt;/strong>:
&lt;img src="https://cmas.dev/img/posts/2022/04/26/Wsl1.png" alt="">&lt;/li>
&lt;li>Cuando termine la instalación debemos reiniciar el sistema operativo y veremos este nuevo enlace en el &lt;strong>Explorador de archivos&lt;/strong>:
&lt;img src="https://cmas.dev/img/posts/2022/04/26/Wsl2.png" alt="">&lt;/li>
&lt;/ol>
&lt;h2 id="instalamos-la-distro-de-preferencia">Instalamos la distro de preferencia&lt;/h2>
&lt;p>En mi caso selecciono Ubuntu, pero existen otras que se encuentran disponibles para su instalación. Aquí procedemos a instalar desde &lt;strong>Microsoft Store&lt;/strong>:
&lt;img src="https://cmas.dev/img/posts/2022/04/26/Wsl3.png" alt="">&lt;/p>
&lt;p>Una vez que haya culminado la instalación, procedemos a abrir la nueva App (sí, se encuentra como una App):
&lt;img src="https://cmas.dev/img/posts/2022/04/26/Wsl4.png" alt="">&lt;/p>
&lt;h2 id="windows-terminal">Windows Terminal&lt;/h2>
&lt;p>Aquí es donde empezamos a disfrutar de nuestra distro de Linux favorita para empezar a jugar con ella.&lt;/p>
&lt;p>Creamos un usuario para nuestro sistema operativo Ubuntu (puede o no ser igual al usuario de Windows):
&lt;img src="https://cmas.dev/img/posts/2022/04/26/Wsl5.png" alt="">&lt;/p>
&lt;p>Por último, accedemos a la terminal de Ubuntu y realizamos las tareas que queramos dentro de Ubuntu, que está dentro de Windows 11.
&lt;img src="https://cmas.dev/img/posts/2022/04/26/Wsl6.png" alt="">&lt;/p>
&lt;p>Podemos verificar que distro estamos ejecutando:
&lt;img src="https://cmas.dev/img/posts/2022/04/26/Wsl7.png" alt="">&lt;/p>
&lt;p>¡Espero resulte útil!&lt;/p></description></item></channel></rss>